<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java基础数据类型和运算符</title>
    <url>/2021/01/25/Java%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p><strong>标识符</strong>是赋给类、方法、变量……的<strong>名字</strong>。<br>一个标识符可以是<strong>字母、数字、下划线、美元符号</strong>的任意顺序组合，但不能以一个数字开始，也不能是关键字。<br><strong>注:Java是区分大小写的，Student和student是不一样的</strong><br>==由于Java采用的Unicode编码，所以中文也算是字母，但是并不建议用中文做标识符==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> 中文 = <span class="number">5</span>;</span><br><span class="line">System.out.println(中文); <span class="comment">// 输出5</span></span><br></pre></td></tr></table></figure>

<h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p><strong>关键字</strong>是Java里事先定义好并赋予特殊含义的单词，也被称为保留字，标识符不能和关键字冲突。<br><img src="https://img-blog.csdnimg.cn/20210125200259566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZ3JldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>==注意：main不是关键字==</p>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>常量就是在程序中固定不变的值，是不能改变的数据。例如数字1，字符‘a’，浮点数3.2等。在Java中，常量包括==整型常量、浮点数常量、布尔常量、字符常量==等等。</p>
<h2 id="1-整型常量"><a href="#1-整型常量" class="headerlink" title="1.整型常量"></a>1.整型常量</h2><p><strong>整型常量</strong>是整数类型的数据，有二进制，八进制，十进制和十六进制四种表示形式：</p>
<ul>
<li>二进制：由数字0和1组成的数字序列，前面要以0b或0B开头，目的是为了和十进制进行区分，如0b01101100，0B10110101</li>
<li>八进制：以0开头并且其后由0~7范围内（包含0和7）的整数组成的数字序列，如0342。</li>
<li>十进制：由数字0~9范围内（包含0和9）的整数组成的数字序列，如198。</li>
<li>十六进制：以0x或0X开头并且其后由0-9，A-F（包含端点）组成的数字序列，如0X25AF</li>
</ul>
<p>==注意：在程序中为了标明不同的进制，数据都有上述的特定标识，必须遵守。==</p>
<h2 id="2-浮点数常量"><a href="#2-浮点数常量" class="headerlink" title="2.浮点数常量"></a>2.浮点数常量</h2><p><strong>浮点数常量</strong>就是在数学中用到的小数，分为<strong>float单精度浮点数</strong>和<strong>double双精度浮点数</strong>两种类型。其中，单精度浮点数后面以<strong>F或f</strong>结尾，双精度浮点数后面以<strong>D或d</strong>结尾。当然，也可以不加任何的后缀，此时Java虚拟机会默认为double双精度浮点数。</p>
<h2 id="3-字符常量"><a href="#3-字符常量" class="headerlink" title="3.字符常量"></a>3.字符常量</h2><p><strong>字符常量</strong>用于表示一个字符，它可以是英文字母，数字，标点符号以及转义序列来表示的特殊字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> <span class="string">&#x27;1&#x27;</span> <span class="string">&#x27;&amp;&#x27;</span> <span class="string">&#x27;\r&#x27;</span> <span class="string">&#x27;\u0000&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="4-字符串常量"><a href="#4-字符串常量" class="headerlink" title="4.字符串常量"></a>4.字符串常量</h2><p><strong>字符串常量</strong>用于表示一串连续的字符。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;Hello World&quot;</span> <span class="string">&quot;123&quot;</span> <span class="string">&quot;Welcome \n XXX&quot;</span>  <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="5-布尔常量"><a href="#5-布尔常量" class="headerlink" title="5.布尔常量"></a>5.布尔常量</h2><p><strong>布尔常量</strong>即布尔型的两个值==true==和==false==，该常量用于区分一个事物的真与假</p>
<h2 id="6-null常量"><a href="#6-null常量" class="headerlink" title="6.null常量"></a>6.null常量</h2><p><strong>null常量</strong>只有一个值null，表示对象的引用为空。</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h2><p>在程序运行期间，随时可能产生一些临时数据，应用程序会将这些数据保存在一些内存单元中，每个内存单元都用一个标识符来标识。这些<strong>内存单元</strong>被称为==变量==，定义的<strong>标识符</strong>就是==变量名==，<strong>内存单元中存储的数据</strong>就是==变量的值==。</p>
<h2 id="变量的数据类型"><a href="#变量的数据类型" class="headerlink" title="变量的数据类型"></a>变量的数据类型</h2><p>在JAVA中的变量数据类型分为两种：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。<br><img src="https://img-blog.csdnimg.cn/20210125204512507.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZ3JldA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="https://blog.csdn.net/ThinkWon/article/details/101649568?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522161157846516780265429893%252522%25252C%252522scm%252522%25253A%25252220140713.130102334..%252522%25257D&request_id=161157846516780265429893&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-101649568.pc_search_result_hbase_insert&utm_term=Java%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">此图从这篇博客转载而来</a></p>
<p><strong>操作误区</strong>：<br>定义一个long变量时，如果用常量给他赋值，并且这个常量的值超过了int的范围，则一定要在这个常量后面加一个L或者l。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> val = <span class="number">9999999999999L</span>；</span><br></pre></td></tr></table></figure>

<p>定义一个float变量时，如果用常量给他赋值，并且这个常量是小数，则必须在这个常量后面加个f或者F，因为小数会被默认为double类型的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> val = <span class="number">1.2f</span>;</span><br></pre></td></tr></table></figure>
<p>定义一个boolean变量，只能用true或者false给他赋值，并不能用0或1去赋值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>; <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="number">1</span>; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>

<h2 id="变量类型的转换"><a href="#变量类型的转换" class="headerlink" title="变量类型的转换"></a>变量类型的转换</h2><h3 id="1-自动类型转换"><a href="#1-自动类型转换" class="headerlink" title="1.自动类型转换"></a>1.自动类型转换</h3><p>自动类型转换也叫隐式类型转换，指的是两种数据类型在转换的过程中不需要显式地进行声明。<br>他需要两个条件：第一，<strong>两种数据类型彼此兼容</strong>；第二，<strong>目标类型的取值范围大于源类型的取值范围</strong>（==目标类型可以类比成水桶，源类型可以类比成水杯==）<br>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> a = b; <span class="comment">// 程序把byte类型的b自动转换成了int类型，无须特殊声明</span></span><br></pre></td></tr></table></figure>
<p>下面列举三种可以进行自动类型转换的情况：</p>
<ul>
<li>整数类型之间可以实现转换，低取值范围的向高取值范围转换</li>
<li>整数类型可以转换成float类型。</li>
<li>其他类型可以转换成double类型。</li>
</ul>
<h3 id="2-强制类型转换"><a href="#2-强制类型转换" class="headerlink" title="2.强制类型转换"></a>2.强制类型转换</h3><p>强制类型转换也叫显式类型转换，指的是两种数据类型之间需要进行显式地声明。<br>当两种类型彼此不兼容，或者目标类型的取值范围小于源类型时，自动类型转换无法进行，这时就需要强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">目标类型 变量名 = （目标类型） 值；</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>) num;</span><br></pre></td></tr></table></figure>
<p>==注意==：在对变量进行强制类型转换时，会发生取<strong>值范围较大的数据类型向取值范围较小的数据类型的转换</strong>，如将一个int类型的数转换成byte类型，这样极其容易造成<strong>数据精度的丢失</strong>。因为两者的取值范围不同，所以小范围的数据类型会截断大范围的数据类型，造成精度丢失。<br>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">128</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>) a;</span><br><span class="line">System.out.println(b); <span class="comment">// 输出-128，精度丢失，具体原理：自行写出他们的二进制表示即可理解</span></span><br></pre></td></tr></table></figure>

<h3 id="3-表达式类型的自动提升"><a href="#3-表达式类型的自动提升" class="headerlink" title="3.表达式类型的自动提升"></a>3.表达式类型的自动提升</h3><p>所谓表达式是指由变量和运算符组成的一个算式，变量在表达式中进行运算时，也有可能发生自动类型转换，这就是表达式数据类型的自动提升，如一个byte型的变量在运算期间类型会自动提升为int型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span> b1 = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> b2 = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">byte</span> b = b1 + b2; <span class="comment">// 此时报错，因为在运算期间，变量b1和变量b2都被提升为了int型，直接赋值就会出错</span></span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>) (b1 + b2); <span class="comment">// 此时成功 </span></span><br></pre></td></tr></table></figure>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>理解一个点，其他的和c++一样，不再赘述。<br>==| 或，|| 短路或，&amp; 与，&amp;&amp;短路与==</p>
<ul>
<li>| 或：无论左式的真假性，都要计算运算符两边的表达式</li>
<li>|| 短路或：当<strong>左式</strong>为<strong>真</strong>时，就判断<strong>整个式子为真</strong>，不再计算判断右式</li>
<li>&amp; 与：无论左式的真假性，都要计算运算符两边的表达式</li>
<li>&amp;&amp; 短路与：当<strong>左式</strong>为<strong>假</strong>时，就判断<strong>整个式子为假</strong>，不再计算判断右式</li>
</ul>
<p>举例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>, z = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag1, flag2;</span><br><span class="line">flag1 = x &gt; <span class="number">0</span> &amp; y++ &gt; <span class="number">0</span>; <span class="comment">// 最终y的值为1，因为右式计算判断过了</span></span><br><span class="line">flag2 = x &gt; <span class="number">0</span> &amp;&amp; z++ &gt; <span class="number">0</span>; <span class="comment">// 最终z的值为0，因为右式没有计算判断过</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>c++重载运算符时返回值为类的对象或者返回对象的引用</title>
    <url>/2020/08/02/c-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E6%97%B6%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%88%96%E8%80%85%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>最终的目的是为了进行连续的运算</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = b + c + d; <span class="comment">//不只是两个对象相加，是为了两个以上的对象的相加</span></span><br></pre></td></tr></table></figure>
<p>以上面的代码为例，假设a,b,c,d都是同一个类（classA）的不同对象，假如我重载这个类的加号时，返回值类型不是此类或者他的引用，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>+(classA &amp;a, classA &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//加法运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么在我最上面的代码中，b + c 的值就为空（或者其他类型），那么这个得出来的值就没有办法继续和d来进行加法的运算，也没有办法赋值给a了，这也就无法实现我所期望的连续运算的目的。<br>所以，==c++重载运算符时返回值为类的对象是为了实现连续的运算(大多数这种运算其实是赋值运算或者&lt;&lt;    &gt;&gt;)==<br>如果你以后要重载运算符，有什么连续运算的需要，就可以使用这种方法，不过最好也要遵守c++中一些语法的规定，不要重载出来的东西让人摸不着头脑</p>
<p>那么，现在讲为什么有一些函数要返回对象的引用，这其实是为了提高程序的运行效率，众所周知，当一个函数返回一个值时，他并不是将你在此函数里面原有的你想要的那个值返回，而是将你想要的那个值，复制一下，然后把这个复制出来的值给返回，如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">classA <span class="keyword">operator</span>+(classA &amp;a, classA &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	classA temp;</span><br><span class="line">	<span class="comment">//加法运算</span></span><br><span class="line">	<span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码最终返回的并不是你在函数里定义的那个temp，而是将temp复制了一份，将复制的那份返回了，函数里定义的那个temp在函数运行结束后就释放了。同理，就算你没有在函数里面新建东西，而是直接返回通过a和b运算出来的一些东西（==或者你直接返回*this==），他也要复制一下。</p>
<p>所以，只要你不采用返回类的对象，而是返回类的对象的引用，就不会复制，也即不会调用类的复制构造函数，也即提升了程序的效率</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">classA &amp; <span class="keyword">operator</span>+(classA &amp;a, classA &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//加法运算</span></span><br><span class="line">	<span class="comment">//a.time = a.time + b.time; //假设time是此类的一个属性</span></span><br><span class="line">	<span class="comment">//return a;</span></span><br><span class="line">	<span class="comment">//加法只有这样可以实现连续的运算，有些鸡肋，但是=，&lt;&lt;，&gt;&gt;,就很好用了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>==所以，当你重载的运算符需要连续的运算时，你可以返回他的类的对象。如果你想要减少不必要的开销（复制构造函数），提高程序效率，并且你返回的对象是需要作为左值的话，那么你可以返回他的引用==</p>
<p>==不过绝大部分  返回对象  或者  他的引用  实现连续运算，都是用在重载 赋值运算符= 或者 插入运算符&lt;&lt; 或者 提取运算符&gt;&gt; 中的。那里面比较好用，其他的如加法那些，连续运算就很鸡肋，也比较难实现，但是返回引用可以提升效率却是真真的好啊==</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++中单继承构造函数与析构函数的调用顺序</title>
    <url>/2020/08/05/c-%E4%B8%AD%E5%8D%95%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>在c++的单继承中，构造函数有3个需要调用的地方</p>
<ol>
<li>基类构造函数</li>
<li>子对象构造函数</li>
<li>派生类本身的构造函数</li>
</ol>
<p>调用的顺序为：</p>
<ol>
<li>调用基类构造函数，对基类数据成员初始化</li>
<li>调用子对象构造函数，对子对象数据成员初始化</li>
<li>调用派生类构造函数，对派生类数据成员初始化</li>
</ol>
<p>基类和派生类的构造函数相信不用多说了，前者优先于后者，需要注意的是这里面的子对象的构造函数。<br>注意：==在每一个类中，不管他是基类还是派生类，子对象的构造函数的调用都优先于此类本身的构造函数调用==<br>只要搞清楚了构造函数的顺序，一但遇到了析构函数，只要把构造函数反过来看，就是析构函数的调用顺序了。<br>实验代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> // 实验的子对象类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造D&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">D</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构D&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span> // 实验的子对象类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">E</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造E&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">E</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构E&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;构造A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//D d;</span></span><br><span class="line">    <span class="comment">//E e;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;构造B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//D d;</span></span><br><span class="line">    <span class="comment">//E e;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">C</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;析构C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    D d;</span><br><span class="line">    E e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200805173620805.png" alt="运行结果"></p>
<p>注意：==在每个类中，如果有多个子对象，那么他们构造函数的调用顺序取决于他们的声明顺序，声明越早，构造越早。如上面代码中在类C中子对象d, e的构造函数调用，因为d的声明在e之前，所以的d的构造函数先调用==</p>
<p>现在将两个子对象放到类B中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造D&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">D</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构D&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">E</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造E&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">E</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构E&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;构造A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//D d;</span></span><br><span class="line">    <span class="comment">//E e;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;构造B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    D d;</span><br><span class="line">    E e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">C</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;析构C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//D d;</span></span><br><span class="line">    <span class="comment">//E e;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/2020080517410424.png" alt="运行结果"></p>
<p>下面将子对象放到类A中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">D</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造D&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">D</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构D&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">E</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">E</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造E&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">E</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构E&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;构造A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构A&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    D d;</span><br><span class="line">    E e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span><span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt; <span class="string">&quot;构造B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">B</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;析构B&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//D d;</span></span><br><span class="line">    <span class="comment">//E e;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">C</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;析构C&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//D d;</span></span><br><span class="line">    <span class="comment">//E e;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    C c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果如下：<br><img src="https://img-blog.csdnimg.cn/20200805174233894.png" alt="运行结果"></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>c++的字符及字符串简记</title>
    <url>/2020/06/28/c-%E7%9A%84%E5%AD%97%E7%AC%A6%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%80%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h1><p>字符常量：用单撇号括起来的==一个==<strong>字符</strong>就是字符常量。（注意是一个）</p>
<p>如：**’A’，’a’，’1’，’2’。**</p>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><p>转义字符是一种特殊的字符，他有两个或多个字符组成，但是他只代表一个字符。</p>
<p>编译系统在见到字符“\”后，==会接着找他后面的字符==，并且把它处理成一个字符，在内存中只占一个字节。</p>
<p>转义字符’ \ ‘代表的反斜杠” \ “，转义字符” \’ “代表的字符” ‘ “和转义字符’ &quot; ‘代表的字符’＂’，其本身就是可显示字符，为什么还要对它转义呢?</p>
<p>这是因为它们的原有的字符形式已==作它用==，其中，单引号用作<strong>区分字符常量的括号</strong>，双引号用作<strong>区分字符串的括号</strong>，而反斜杠本身已用来<strong>表示转义字符的开头</strong>，因此必须对它们用转义字符重新声明。</p>
<p>转义字符注意点：<br>1)转义字符中只能使用小写字母，每个转义字符只能看作一个字符。<br>如：<strong>\n</strong>(换行), <strong>\t</strong>(制表符), <strong>\a</strong>(响铃，你的电脑会叫一声), <strong>\0</strong>(空字符)，以上只能小写，还有的如“\101”(字母A)，这则是八进制的方法，还有16进制的，如果需要请自行查找</p>
<p>2)\v垂直制表和\f换页符对<strong>屏幕</strong>（你的小黑框）没有任何影响，但会影响打印机执行响应操作。</p>
<p>4)转义字符’\0’表示空字符<strong>NULL</strong>，它的值是<strong>0</strong>。而字符’0’的ASCII码值是48。因此，空字符’\0’不是字符0。另外，空字符不等于空格字符，空格字符的ASCII码值为32而不是0。</p>
<p>5)如果反斜线之后的字符和它不构成转义字符，则’\’不起转义作用将被<strong>忽略</strong>。<br>如：你输出“\c”,”\A”，最后只会出来”c”和“A”。</p>
<p>6）转义字符也经常出现在字符串中，如你在一句话的末尾加一个\n，这时候就会换行，注意，这个时候\n是当做<strong>一个字符</strong>看待的，不是当做两个看待的。</p>
<h1 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h1><p>对字符数组的初始化。<br>如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>如果花括号里面提供的字符个数大于规定的数组长度，则按<strong>语法错误处理</strong>。<br>如果花括号里面提供的字符个数小于规定的数组长度，则按顺序将这些初值赋给前面的那些元素，其余元素用<strong>空字符</strong>（’\0’）填充。</p>
<p>注意：==只能对字符数组的元素赋值，而不能用赋值语句对整个数组赋值==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>];</span><br><span class="line">c = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;y&#x27;</span>&#125;; <span class="comment">//错误，不能对整个数组一次性赋值，只有初始化的时候可以类似地这样做</span></span><br><span class="line">c[<span class="number">0</span>] = <span class="string">&#x27;C&#x27;</span>;</span><br><span class="line">c[<span class="number">1</span>] = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">c[<span class="number">3</span>] = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">c[<span class="number">4</span>] = <span class="string">&#x27;n&#x27;</span>;</span><br><span class="line">c[<span class="number">5</span>] = <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 这样是正确的</span></span><br></pre></td></tr></table></figure>
<p>如果已经有a和b两个数组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = b; <span class="comment">// 错误，不能对整个数组整体赋值</span></span><br><span class="line">a[<span class="number">0</span>] = b[<span class="number">0</span>]; <span class="comment">// 正确，对数组元素赋值</span></span><br></pre></td></tr></table></figure>

<h1 id="字符数组的输入与输出"><a href="#字符数组的输入与输出" class="headerlink" title="字符数组的输入与输出"></a>字符数组的输入与输出</h1><p>两种方法：<br>1）逐个字符输入输出<br>2）将整个字符串一次输入或输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">20</span>];</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line">cout &lt;&lt; c;<span class="comment">// 输出整个字符串</span></span><br><span class="line">cout &lt;&lt; c[<span class="number">0</span>]; <span class="comment">//输出单个字符</span></span><br></pre></td></tr></table></figure>
<p>字符数组名代表字符数组的第一个元素c[0]的地址，执行 “cout &lt;&lt; c;” 的过程是从c所指向的数组的第一个元素开始<strong>逐个</strong>（自己往后跑，指针自行增加）输出字符，直到遇到’\0’为止。</p>
<p>注意：<br><strong>1）输出的字符不包括结束符’\0’</strong><br><strong>2）如果数组长度大于字符串实际长度，输出遇到‘\0’结束</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">cout &lt;&lt; c; <span class="comment">// 只输出ABC三个字符，而不是10个字符，这就是结束标志的作用</span></span><br></pre></td></tr></table></figure>
<p><strong>3）如果一个字符数组包含一个以上的‘\0’，则遇到第一个‘\0’时输出就结束</strong><br><strong>4）用cin从键盘输入一个字符串时，键盘键入的字符串长度应小于字符数组的长度，否则会出现问题</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">1</span>];</span><br><span class="line">cin &gt;&gt; c; <span class="comment">// 输入123</span></span><br><span class="line">cout &lt;&lt; c; <span class="comment">//输出123</span></span><br><span class="line"><span class="comment">/*系统不报错，也能正常输出，因为他将多余的字符放在了后面的字节里面，</span></span><br><span class="line"><span class="comment">这样有可能会破坏其他的数据，不安全，甚至可能出现无法估计的后果</span></span><br><span class="line"><span class="comment">所以一定要保证字符串长度小于字符数组长度*/</span></span><br></pre></td></tr></table></figure>


<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p>字符串以’\0’作为<strong>结束的标志</strong>，在系统中，当遇到字符<strong>‘\0’</strong>就表示字符串到此结束了，由他前面的字符组成==有效的字符串==。</p>
<p>对于一个字符串常量，系统会自动在所有字符的后面加一个‘\0’作为结束符，然后再把他给存起来。<br>如：对字符串常量“ABC”，共有3个字符，但是他在内存里面却有4个字节，因为还有个‘\0’是系统自动加上的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> != <span class="string">&quot;a&quot;</span>; <span class="comment">//注意，前者有一个字a，占一个字节，后者有a和\0两个字符，占两个字节</span></span><br></pre></td></tr></table></figure>

<p>所以，在程序中常常依靠检测’\0’的位置来判断字符串是否结束，而不是根据字符数组规定的长度来决定字符串的长度。（注意：如果要用字符数组存字符串，一定要记得让字符数组长度<strong>大于</strong>字符串长度哦）</p>
<p>可以用字符串常量来初始化字符数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = <span class="string">&quot;ABC&quot;</span>; <span class="comment">//注意两边是双撇号</span></span><br><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">//第一行与这一行等价</span></span><br><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;; <span class="comment">// 与这一行不等价</span></span><br></pre></td></tr></table></figure>
<p>说明：<strong>字符数组并不要求最后一个字符必须是‘\0’，可以不包括‘\0’，随程序设计者需要而定，但为了使字符串的处理方法一致（==遇到’\0’结束==），人们往往认为地在字符数组的最后加上一个’\0’。</strong></p>
<h2 id="字符串类"><a href="#字符串类" class="headerlink" title="字符串类"></a>字符串类</h2><p>字符数组操控字符串的方法太过麻烦，在字符串的运算中，一但字符串的长度超过了字符数组的长度，会带来不必要的危险，所以我们经常是用string来处理日常的字符串的。<br>在使用方法上，他和int，char一样，只不过你需要先：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>下面介绍运算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line">string s1，s2; <span class="comment">// 定义字符串</span></span><br><span class="line">s1 = <span class="string">&quot;ABC&quot;</span>; <span class="comment">// 赋值</span></span><br><span class="line">s2 = s1; <span class="comment">// 赋值</span></span><br><span class="line"></span><br><span class="line">cin &gt;&gt; s1;</span><br><span class="line">cout &lt;&lt; s1; <span class="comment">// 输入与输出</span></span><br><span class="line"></span><br><span class="line">s1 = s2; <span class="comment">//字符串复制</span></span><br><span class="line">s1 = s1 + s2; <span class="comment">//字符串连接</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">length</span>(); <span class="comment">//输出字符串长度，还有其他的操作方法，请自行查找函数库</span></span><br><span class="line"><span class="comment">// 字符串比较直接用 &gt; &lt; &gt;= &lt;= == != 即可</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：string，cstring，和string.h的<strong>区别</strong></p>
<p>string是C++的==string类==。</p>
<p>cstring包含一些C字符串的==操作函数==，它里面有一些常用的C字符串处理函数，比如strcmp、strlen、strcpy、strcat之类的函数，它与原来的&lt;string.h&gt;对应。但cstring头文件的内容在名字空间std 中，而string.h不在。</p>
<p>==cstring里面的函数不能操作string对象==，string对象有它自己的函数来操作，cstring可以和纯字符串（“ABC”）或者字符数组玩耍。</p>
<p>下面引用一下别人关于头文件的说明并作了些增添：</p>
<blockquote>
<p>下面是C++头文件的现状：<br>(1)旧的C++头文件名如 &lt;iostream.h&gt;将会继续被支持，这些头文件的内容不在名字空间std 中。新的C++头文件如 iostream包含的基本功能和对应的旧头文件相同，但头文件的内容在名字空间std 中。（在标准化的过程中，库中有些部分的细节被修改了，所以旧头文件和新头文件中的实体不一定完全对应。）<br>(2)标准C 头文件如 &lt;stdio.h&gt;继续被支持。头文件的内容不在std 中。具有C 库功能的新C++头文件具有如 cstdio这样的名字。它们提供的内容和相应的旧C 头文件相同，只是内容在std 中。<br>前面加个c代表着它是继承标准c的头文件。</p>
</blockquote>
<p>==由于cin的输入会跳过空格，换行，tab符之类的空白字符，所以有时候会使用getline函数来进行输入==</p>
<p>当用getline函数进行输入操作时，对字符数组</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[Asize];</span><br><span class="line">   cin.<span class="built_in">getline</span>(name, Asize,<span class="string">&#x27;结束字符&#x27;</span>); <span class="comment">// 注意格式，一般第三个参数不输入的话默认为换行符</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>面向行的输入:istream&amp; getline(char *p, int n, char c)<br>getline()函数读取整行，它使用通过回车键输入的换行符来确定输入结尾。要调用这种方法，可以使用cin.getline()。该函数有两个参数。第一个参数是用来存储输入行的数组的名称，第二个参数是要读取的字符数量。如果参数是20，那么最多可以读取19个字符，余下的空间用于存储自动在结尾处添加的空字符。如果在读取n-1个字符之前遇到终止字符(第三个参数不写，默认为’\n’)，则提前结束。getline()成员函数在读取指定数目的字符或遇到换行符时停止读取。</p>
</blockquote>
<p>当用getline函数进行输入操作时，对字符串</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string name;</span><br><span class="line">   <span class="built_in">getline</span>(cin, name);   <span class="comment">// 注意格式</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>getline(cin, inputLine)，其中cin是正在读取的输入流，而inputLine是接收输入字符串的string变量的名称。需要注意的是，它不是类方法。</p>
</blockquote>
<h2 id="get和getline的区别"><a href="#get和getline的区别" class="headerlink" title="get和getline的区别"></a>get和getline的区别</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cin.<span class="built_in">getline</span>(name, Asize,<span class="string">&#x27;结束字符&#x27;</span>);</span><br><span class="line">cin.<span class="built_in">get</span>(name, Asize,<span class="string">&#x27;结束字符&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>==getline<strong>不会保留</strong>结束字符在缓冲区，而get<strong>会保留</strong>结束字符在缓冲区==</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];<span class="keyword">char</span> b;</span><br><span class="line">   cin.<span class="built_in">get</span>(a,<span class="number">10</span>,<span class="string">&#x27;,&#x27;</span>);<span class="comment">// get</span></span><br><span class="line">cin.<span class="built_in">get</span>(b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl&lt;&lt;b;</span><br><span class="line"><span class="comment">//输入12345，回车</span></span><br><span class="line"><span class="comment">//输出12345【换行】，</span></span><br><span class="line"><span class="comment">//注意，因为缓冲区里面还有逗号（结束字符），</span></span><br><span class="line"><span class="comment">//所以在get单个字符的时候，就直接把这个结束字符获取了</span></span><br><span class="line"><span class="comment">//cin.get(a,10,&#x27;,&#x27;)把12345到a中，遇到&#x27;,&#x27;结束，但是不把&#x27;,&#x27;删除，而把&#x27;,&#x27;输入到b中</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">10</span>];<span class="keyword">char</span> b;</span><br><span class="line">   cin.<span class="built_in">getline</span>(a,<span class="number">10</span>,<span class="string">&#x27;,&#x27;</span>); <span class="comment">//getline</span></span><br><span class="line">cin.<span class="built_in">get</span>(b);</span><br><span class="line">cout&lt;&lt;a&lt;&lt;endl&lt;&lt;<span class="built_in"><span class="keyword">int</span></span>(b);</span><br><span class="line"><span class="comment">//输入12345，回车</span></span><br><span class="line"><span class="comment">//输出12345【换行】10</span></span><br><span class="line"><span class="comment">//cin.getline(a,10,&#x27;,&#x27;)把12345输入到a中，遇到’，‘结束，并删除缓冲区的‘,’，</span></span><br><span class="line"><span class="comment">//后面的[enter]输入到b中</span></span><br><span class="line"><span class="comment">//回车的ascil码为10</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>codeblocks编译运行c++文件显示“不支持的16位应用程序，与64位版本的Windows不兼容”的解决办法</title>
    <url>/2020/03/19/codeblocks%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8Cc-%E6%96%87%E4%BB%B6%E6%98%BE%E7%A4%BA%E2%80%9C%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9A%8416%E4%BD%8D%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%8C%E4%B8%8E64%E4%BD%8D%E7%89%88%E6%9C%AC%E7%9A%84Windows%E4%B8%8D%E5%85%BC%E5%AE%B9%E2%80%9D%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>有一天我想写一个东西来实现一下自己脑子里的思路，编译运行的时候却显示了这个东西<img src="https://img-blog.csdnimg.cn/20200319143305983.bmp?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZ3JldA==,size_16,color_FFFFFF,t_70"><br>我上网查了很多，有人说应该把腾讯手游助手等腾讯的游戏软件卸载，可是等我卸载后却并没有解决问题。<br>后来，我突发奇想打开了以前写的cpp文件，发现他竟然能够编译运行！！！（卸载腾讯手游助手后）<br>我又创建了一个新的文件，发现竟然也能运行！！！<br>只有这一个cpp文件不能运行，于是我把这个cpp文件删除了，完美地解决了这个问题。</p>
<p>这可能因为腾讯手游助手等软件只要你运行过后，他就会修改你系统的某些东西。当你在  有腾讯手游助手  的背景下运行codeblocks的文件时，那么这个文件一但编译运行，他的内在就被修改了，即使你把腾讯手游助手卸载了，它也被修改了，所以这个文件就完了。（这就是一开始我以为卸载后没有解决问题的原因，因为我还在死扣那个坏文件）<br>但是当你把腾讯手游助手这类软件卸载了，再打开以前写的文件，由于他没有在 有腾讯手游助手  的背景下编译运行过，所以他没事，能够正常使用，同理，创建新文件能运行也是这个道理。<br>总的来说，应该就是腾讯手游助手这类软件为了游戏的正常使用而不得已修改一些系统的东西，造成了这个后果，将其卸载后再把不能运行的cpp（cbp）文件删除即可得到舒服的codeblocks使用环境了。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>codeblocks</tag>
      </tags>
  </entry>
  <entry>
    <title>实验一：顺序表及其应用——顺序表的基本操作及有序表的合并</title>
    <url>/2021/01/28/%E5%AE%9E%E9%AA%8C%E4%B8%80%EF%BC%9A%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8F%8A%E6%9C%89%E5%BA%8F%E8%A1%A8%E7%9A%84%E5%90%88%E5%B9%B6/</url>
    <content><![CDATA[<h1 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h1><p>帮助学生熟练掌握线性表的顺序存储结构（顺序表）的基本操作及其简单应用，实现两个有序表的合并操作。</p>
<h1 id="【实验内容及要求】"><a href="#【实验内容及要求】" class="headerlink" title="【实验内容及要求】"></a>【实验内容及要求】</h1><ol>
<li>实现顺序表的各种基本操作，包括创建顺序表、插入和删除指定序号的元素、读取表元、获取最大和最小值元素、查找元素、表元素的排序、表元素逆置、顺序表的输入和输出等等；</li>
<li>实现两个有序顺序表的合并。问题描述：创建两个有序的顺序表L1和L2，表中元素值由键盘随机输入，再将它们合并为一个新的顺序表L3,合并后L3仍然有序（重复元素只保留一个），最后输出顺序表中的各个元素值。</li>
<li>设计测试用例，测试基本操作和合并操作的正确性。</li>
<li>实现说明：这是第一个上机描述和实现的数据结构类型，旨在让学生加深对数据结构、逻辑结构、存储结构和算法及算法时间复杂度等概念的理解。<h1 id="【实验代码】"><a href="#【实验代码】" class="headerlink" title="【实验代码】"></a>【实验代码】</h1><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxlength 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//int data[Maxlength]; // 顺序表元素</span></span><br><span class="line">    <span class="keyword">int</span> * data;</span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 当前长度</span></span><br><span class="line">&#125;SqList; <span class="comment">// 结构体定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createList</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 创建顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inputNum</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 修改指定位置元素的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showNum</span><span class="params">(SqList &amp;L)</span></span>; <span class="comment">// 展示顺序表元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertNum</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 在指定位置插入元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteNum</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 删除指定位置元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkNum</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> n)</span></span>; <span class="comment">// 读取指定位置元素的数据</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getMaxAndMinNum</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> &amp;max, <span class="keyword">int</span>&amp;min)</span></span>; <span class="comment">//获取最大和最小元素，并分别赋值给max和min</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNum</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> x)</span></span>; <span class="comment">// 查找指定元素的索引，并返回他在顺序表中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortList</span><span class="params">(SqList &amp;L)</span></span>; <span class="comment">// 排序表元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverseList</span><span class="params">(SqList &amp;L)</span></span>; <span class="comment">// 逆置顺序表</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SqList sqList; <span class="comment">// 定义顺序表</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">createList</span>(sqList, <span class="number">10</span>); <span class="comment">// 创建顺序表</span></span><br><span class="line">    <span class="built_in">showNum</span>(sqList); <span class="comment">// 展示顺序表元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">inputNum</span>(sqList,<span class="number">110</span>,<span class="number">5</span>); <span class="comment">// 修改顺序表的第5个元素的值</span></span><br><span class="line">    <span class="built_in">showNum</span>(sqList); <span class="comment">// 展示顺序表元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">checkNum</span>(sqList,<span class="number">5</span>); <span class="comment">// 读取顺序表中的第5个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">insertNum</span>(sqList,<span class="number">120</span>,<span class="number">4</span>); <span class="comment">// 在顺序表的第4个位置插入元素</span></span><br><span class="line">    <span class="built_in">showNum</span>(sqList); <span class="comment">// 展示顺序表元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sortList</span>(sqList); <span class="comment">// 将顺序表排序</span></span><br><span class="line">    <span class="built_in">showNum</span>(sqList); <span class="comment">// 展示顺序表元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">deleteNum</span>(sqList,<span class="number">10</span>); <span class="comment">// 删除顺序表中的第10号元素</span></span><br><span class="line">    <span class="built_in">showNum</span>(sqList); <span class="comment">// 展示顺序表元素</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">findNum</span>(sqList,<span class="number">5</span>); <span class="comment">// 寻找顺序表中是否有元素12</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxNum, minNum;</span><br><span class="line">    <span class="built_in">getMaxAndMinNum</span>(sqList,maxNum,minNum);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;此顺序表的最大元素是&quot;</span> &lt;&lt; maxNum &lt;&lt; <span class="string">&quot;, 最小元素是&quot;</span> &lt;&lt; minNum &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inverseList</span>(sqList);</span><br><span class="line">    <span class="built_in">showNum</span>(sqList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createList</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> n)</span> <span class="comment">// 创建顺序表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.data = <span class="keyword">new</span> <span class="keyword">int</span>[Maxlength];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inputNum</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> <span class="comment">// 修改指定位置元素的数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || n &gt; L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;索引异常，无法修改&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//修改失败，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L.data[n<span class="number">-1</span>] = x;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 修改成功，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showNum</span><span class="params">(SqList &amp;L)</span> <span class="comment">// 展示顺序表元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;顺序表的元素依次为: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; L.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">insertNum</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> <span class="comment">// 在指定位置插入元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length == Maxlength)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;顺序表元素已满，无法添加!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 插入失败，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || n &gt; L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;索引异常，无法添加&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 插入失败，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = L.length <span class="number">-1</span>; i &gt;= n - <span class="number">1</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[i+<span class="number">1</span>] = L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L.data[n<span class="number">-1</span>] = x;</span><br><span class="line">    L.length++;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 插入成功，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteNum</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> n)</span> <span class="comment">// 删除指定位置元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;顺序表无元素，无法删除&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 删除失败，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || n &gt; L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;索引异常，无法删除&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 删除失败，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n<span class="number">-1</span>; i &lt; L.length - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[i] = L.data[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length--;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除成功!&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 删除成功，返回true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkNum</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> n)</span> <span class="comment">// 读取指定位置元素的数据</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;顺序表的长度为0，无法查找&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 读取失败，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || n &gt; L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;您指定的元素索引超出了范围&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 读取失败，返回false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;号元素为: &quot;</span> &lt;&lt; L.data[n<span class="number">-1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getMaxAndMinNum</span><span class="params">(SqList &amp;L,<span class="keyword">int</span> &amp;max, <span class="keyword">int</span>&amp;min)</span> <span class="comment">//获取最大和最小元素，并分别赋值给max和min</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;顺序表为空，无最值！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    max = min = L.data[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(max &lt; L.data[i])</span><br><span class="line">        &#123;</span><br><span class="line">            max = L.data[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(min &gt; L.data[i])</span><br><span class="line">        &#123;</span><br><span class="line">            min = L.data[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNum</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> x)</span> <span class="comment">// 查找指定元素的索引，并返回他在顺序表中的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L.data[i] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;是顺序表中的第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;个元素&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;元素&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;不在顺序表中!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 此元素不在表中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortList</span><span class="params">(SqList &amp;L)</span> <span class="comment">// 排序表元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = L.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; end; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L.data[j] &gt; L.data[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = L.data[j];</span><br><span class="line">                L.data[j] = L.data[j+<span class="number">1</span>];</span><br><span class="line">                L.data[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;排序完成!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverseList</span><span class="params">(SqList &amp;L)</span> <span class="comment">// 逆置顺序表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length / <span class="number">2</span>; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = L.data[i];</span><br><span class="line">        L.data[i] = L.data[L.length - <span class="number">1</span> - i];</span><br><span class="line">        L.data[L.length - <span class="number">1</span> - i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;逆置成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Maxlength 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> * data; <span class="comment">// 顺序表元素</span></span><br><span class="line">    <span class="keyword">int</span> length; <span class="comment">// 当前长度</span></span><br><span class="line">&#125;SqList; <span class="comment">// 结构体定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createList</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 创建顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showNum</span><span class="params">(SqList &amp;L)</span></span>; <span class="comment">// 展示顺序表元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">combineList</span><span class="params">(SqList L1, SqList L2, SqList &amp;L)</span></span>; <span class="comment">// 合并顺序表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eliminateRepeatingElements</span><span class="params">(SqList &amp;L)</span></span>; <span class="comment">// 消除重复元素</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortList</span><span class="params">(SqList &amp;L)</span></span>; <span class="comment">// 排序表元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqList L1, L2, L3;</span><br><span class="line">    <span class="keyword">int</span> n1, n2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请依次输入你的第一个和第二个顺序表的长度: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n1 &gt;&gt; n2;</span><br><span class="line">    <span class="built_in">createList</span>(L1,n1);</span><br><span class="line">    <span class="built_in">createList</span>(L2,n2);</span><br><span class="line">    <span class="built_in">combineList</span>(L1,L2,L3);</span><br><span class="line">    <span class="built_in">showNum</span>(L3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createList</span><span class="params">(SqList &amp;L, <span class="keyword">int</span> n)</span> <span class="comment">// 创建顺序表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    L.data = <span class="keyword">new</span> <span class="keyword">int</span>[Maxlength];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请依次输入你要为顺序表填充的值: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; L.data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showNum</span><span class="params">(SqList &amp;L)</span> <span class="comment">// 展示顺序表元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;顺序表的元素依次为: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; L.data[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">combineList</span><span class="params">(SqList L1, SqList L2, SqList &amp;L)</span> <span class="comment">// 合并顺序表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L1.length + L2.length &gt; Maxlength)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;合并的两个顺序表长度超出范围，无法合并!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//超出最大存储空间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    L.data = <span class="keyword">new</span> <span class="keyword">int</span>[Maxlength]; <span class="comment">// 为新顺序表分配空间</span></span><br><span class="line">    <span class="keyword">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>, index = <span class="number">0</span>; <span class="comment">// 根据序号依次为三顺序表的实际下标</span></span><br><span class="line">    <span class="keyword">while</span>(index1 &lt; L1.length &amp;&amp; index2 &lt; L2.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L1.data[index1] &lt; L2.data[index2])</span><br><span class="line">        &#123;</span><br><span class="line">            L.data[index++] = L1.data[index1++];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(L1.data[index1] == L2.data[index2])</span><br><span class="line">        &#123;</span><br><span class="line">            L.data[index] = L1.data[index1];</span><br><span class="line">            index++;</span><br><span class="line">            index1++;</span><br><span class="line">            index2++;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            L.data[index++] = L2.data[index2++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index1 &lt; L1.length)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[index++] = L1.data[index1++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(index2 &lt; L2.length)</span><br><span class="line">    &#123;</span><br><span class="line">        L.data[index++] = L2.data[index2++];</span><br><span class="line">    &#125;</span><br><span class="line">    L.length = index;</span><br><span class="line">    <span class="built_in">sortList</span>(L);</span><br><span class="line">    <span class="built_in">eliminateRepeatingElements</span>(L);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sortList</span><span class="params">(SqList &amp;L)</span> <span class="comment">// 排序表元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> end = L.length - <span class="number">1</span>; end &gt; <span class="number">0</span>; end--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; end; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L.data[j] &gt; L.data[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = L.data[j];</span><br><span class="line">                L.data[j] = L.data[j+<span class="number">1</span>];</span><br><span class="line">                L.data[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;排序完成!&quot; &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eliminateRepeatingElements</span><span class="params">(SqList &amp;L)</span> <span class="comment">// 消除重复元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L.data[i] == L.data[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt; L.length; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    L.data[k<span class="number">-1</span>] = L.data[k];</span><br><span class="line">                &#125;</span><br><span class="line">                L.length--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; L.length &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构实验</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实验三：栈的应用——算术表达式求值</title>
    <url>/2021/01/30/%E5%AE%9E%E9%AA%8C%E4%B8%89%EF%BC%9A%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/</url>
    <content><![CDATA[<h1 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h1><p>使学生深入了解栈的特性，以便在实际问题背景下灵活运用栈，同时还将巩固对这种结构的构造方法的掌握及基本操作的实现。</p>
<h1 id="【实验内容】"><a href="#【实验内容】" class="headerlink" title="【实验内容】"></a>【实验内容】</h1><ol>
<li>问题描述：表达式计算是实现程序设计语言的基本问题之一，也是栈的应用的一个典型的例子。设计一个程序，演示用算符优先法对算术表达式求值的过程。</li>
<li>基本要求：以字符序列的形式从终端输入语法正确的、不含变量的整数表达式。利用教科书表3.1给出的算符优先关系，实现对算术四则混合运算表达式的求值，并仿照教科书的例3-1演示在求值中运算符栈、运算数栈、输入字符和主要操作的变化过程。</li>
<li>测试数据：教科书例3-1的算术表达式3*(7-2),以及下列表达式：<br>8；1+2+3+4；88-1<em>5；1024/4</em>8；(20+2)<em>(6/2)；3-3-3；8/(9-9)；2</em>(6+2*(3+6*(6+6)))；(((6+6)*6+3)*2+6)*2。</li>
<li>实现提示：　　<br>（１）、采用优先级法，设置运算符栈和运算数栈，先将表达式转换成后缀表示，然后求值。<br>（２）、在读入表达式的字符序列的同时，完成运算符和运算数（整数）的识别处理，以及相应的运算。<br>（３）、在识别出运算数的同时，要将其字符序列形式转换成整数形式。<br>（４）、在程序的适当位置输出运算符栈、运算数栈、输入字符和主要操作的内容。</li>
</ol>
<h1 id="【实验代码】"><a href="#【实验代码】" class="headerlink" title="【实验代码】"></a>【实验代码】</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> //栈结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T data;</span><br><span class="line">    StackNode&lt;T&gt; *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> // 链栈</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    StackNode&lt;T&gt; *top;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> priority[<span class="number">7</span>][<span class="number">7</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,  <span class="number">1</span>,  <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,  <span class="number">1</span>,  <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">-1</span>, <span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">-1</span>, <span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>,  <span class="number">-2</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">1</span>,  <span class="number">-2</span>, <span class="number">1</span>,  <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">0</span>&#125;</span><br><span class="line">&#125;;    <span class="comment">//优先级关系</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(LinkStack&lt;T&gt; *s)</span></span>; <span class="comment">// 初始化栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(LinkStack&lt;T&gt; *s, T data)</span></span>; <span class="comment">// 入栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(LinkStack&lt;T&gt; *s)</span></span>; <span class="comment">// 出栈</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(LinkStack&lt;T&gt; *s)</span></span>; <span class="comment">// 判断栈是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">GetTop</span><span class="params">(LinkStack&lt;T&gt; *s)</span></span>; <span class="comment">// 返回栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetPriority</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span>; <span class="comment">// 运算符优先级比较</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Operate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> theta, <span class="keyword">int</span> b)</span></span>; <span class="comment">// 运算</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetExpressionValue</span><span class="params">(LinkStack&lt;T1&gt; *OPNd, LinkStack&lt;T2&gt; *OPTr)</span></span>; <span class="comment">// 总计算函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    LinkStack&lt;<span class="keyword">int</span>&gt; *OPNd = <span class="keyword">new</span> LinkStack&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">    LinkStack&lt;<span class="keyword">char</span>&gt; *OPTr = <span class="keyword">new</span> LinkStack&lt;<span class="keyword">char</span>&gt;;</span><br><span class="line">    <span class="built_in">InitStack</span>(OPNd); <span class="comment">// 初始化空栈</span></span><br><span class="line">    <span class="built_in">InitStack</span>(OPTr); <span class="comment">// 初始化空栈</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">push</span>(OPTr, <span class="string">&#x27;#&#x27;</span>); <span class="comment">// 预先压入一个#，为了与表达式最后的#匹配</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入你要计算的表达式，记得在表达式的末尾加上&#x27;#&#x27;! &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">GetExpressionValue</span>(OPNd, OPTr); <span class="comment">// 开始计算</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;答案为：&quot;</span> &lt;&lt; <span class="built_in">GetTop</span>(OPNd); <span class="comment">// 输出运算结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(LinkStack&lt;T&gt; *s)</span> <span class="comment">// 初始化栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//s-&gt;top = new StackNode&lt;T&gt;;</span></span><br><span class="line">    s-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    s-&gt;count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(LinkStack&lt;T&gt; *s, T data)</span> <span class="comment">// 入栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    StackNode&lt;T&gt; *p = <span class="keyword">new</span> StackNode&lt;T&gt;;</span><br><span class="line">    p-&gt;data = data;</span><br><span class="line">    p-&gt;next = s-&gt;top;</span><br><span class="line">    s-&gt;top = p;</span><br><span class="line">    s-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(LinkStack&lt;T&gt; *s)</span> <span class="comment">// 出栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">StackEmpty</span>(s)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;栈为空，无元素可弹出！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode&lt;T&gt; *p = s-&gt;top;</span><br><span class="line">    s-&gt;top = p-&gt;next;</span><br><span class="line">    s-&gt;count--;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(LinkStack&lt;T&gt; *s)</span> <span class="comment">// 判断栈是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">GetTop</span><span class="params">(LinkStack&lt;T&gt; *s)</span> <span class="comment">// 返回栈顶元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;top == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;栈为空，无栈顶元素！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;class T1, class T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetExpressionValue</span><span class="params">(LinkStack&lt;T1&gt; *OPNd, LinkStack&lt;T2&gt; *OPTr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> theta; <span class="comment">// 记录运算符</span></span><br><span class="line">    <span class="keyword">char</span> ch; <span class="comment">// 记录每次输入的字符</span></span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; ch; <span class="comment">//载入第一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (ch != <span class="string">&#x27;#&#x27;</span> || <span class="built_in">GetTop</span>(OPTr) != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">            <span class="keyword">int</span> data = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) &#123;</span><br><span class="line">                data = data * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                cin &gt;&gt; ch;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">push</span>(OPNd, data); <span class="comment">// 将最新的数字压入栈中</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (<span class="built_in">GetPriority</span>(<span class="built_in">GetTop</span>(OPTr), ch)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">-1</span>: <span class="comment">// 栈顶运算符优先级小于新运算符</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">push</span>(OPTr, ch);</span><br><span class="line">                    cin &gt;&gt; ch;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">// 栈顶运算符优先级等于新运算符，只有两种情况，（）和##，##不会出现，所以只会是（），所以只需弹出左括号即可</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">pop</span>(OPTr);</span><br><span class="line">                    cin &gt;&gt; ch;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// 栈顶运算符优先级大于新运算符，开始计算</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> a, b;</span><br><span class="line">                    theta = <span class="built_in">GetTop</span>(OPTr); <span class="comment">// 获取栈顶运算符</span></span><br><span class="line">                    <span class="built_in">pop</span>(OPTr);</span><br><span class="line">                    b = <span class="built_in">GetTop</span>(OPNd); <span class="comment">// 获取此时栈顶第一号数据</span></span><br><span class="line">                    <span class="built_in">pop</span>(OPNd);</span><br><span class="line">                    a = <span class="built_in">GetTop</span>(OPNd); <span class="comment">// 获取此时栈顶第二号数据</span></span><br><span class="line">                    <span class="built_in">pop</span>(OPNd);</span><br><span class="line">                    <span class="built_in">push</span>(OPNd, <span class="built_in">Operate</span>(a, theta, b)); <span class="comment">// 将运算结果压入栈中</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetPriority</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span> <span class="comment">// 运算符优先级比较</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            i = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            i = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            i = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            i = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            i = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            i = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (b) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>:</span><br><span class="line">            j = <span class="number">6</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            j = <span class="number">5</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            j = <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            j = <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            j = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            j = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> priority[i][j];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Operate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">char</span> theta, <span class="keyword">int</span> b)</span> <span class="comment">// 运算</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (theta) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">            res = a + b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            res = a - b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">            res = a * b;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;分母为零，运算出错！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                res = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res = a / b;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构实验</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实验五：树及其应用——哈夫曼树</title>
    <url>/2021/02/02/%E5%AE%9E%E9%AA%8C%E4%BA%94%EF%BC%9A%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
    <content><![CDATA[<h1 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h1><p>通过本次实验使学生了解哈夫曼树的结构特性及其基本操作的实现过程，同时掌握在实际问题背景下的应用开发能力。</p>
<h1 id="【实验内容】"><a href="#【实验内容】" class="headerlink" title="【实验内容】"></a>【实验内容】</h1><ol>
<li>问题描述：利用哈夫曼编码进行通信可以大大提高信道利用率，缩短信息传输时间，降低传输成本。但是，这要求在发送端通过一个编码系统对待传数据预先编码，在接收端将传来的数据进行译码（复原）。对于双工信道（即可以双向传输信息的信道），每端都需要一个完整的编／译码系统。试为这样的信息收发站写一个哈夫曼码的编／译码系统。</li>
<li>基本要求：<br>　　一个完整的系统应具有以下功能：<br>（１）、Ｉ：初始化（Initialization）。从终端读入字符集大小n,以及n个字符和n个权值，建立哈夫曼树，并将它存于文件hfmTree中。<br>（２）、Ｅ：编码（Encoding）。利用以建好的哈夫曼树（如不在内存，则从文件hfmTree中读入），对文件ToBeTran中的正文进行编码，然后将结果存入文件CodeFile中。<br>（３）、Ｄ：译码（Decoding）。利用已建好的哈夫曼树将文件CodeFile中的代码进行译码，结果存入文件TextFile中。<br>（４）、Ｐ：印代码文件（Print）。将文件CodeFile以紧凑格式显示在终端上，每行50个代码。同时将此字符形式的编码文件写入文件CodePrin中。<br>（５）、Ｔ：印哈夫曼树（Tree printing）。将已在内存中的哈夫曼树以直观的方式（树或凹入表形式）显示在终端上，同时将此字符形式的哈夫曼树写入文件TreePrint中。</li>
<li>测试数据：见上机指导书Ｐ149测试数据。（此处测试数据写在代码的首部）</li>
<li>实现提示：<br>　（1）、用户界面可以设计为“菜单”方式：显示上述功能符号，再加上“Ｑ”，表示退出运行Quit。请用户键入一个选择功能符。此功能执行完毕后再显示此菜单，直至某次用户选择了“Ｑ”为止。<br>　（2）、在程序的一次执行过程中，第一次执行I,D或Ｃ命令之后，哈夫曼树已经在内存了，不必读入。每次执行中不一定执行Ｉ命令，因为文件hfmTree可能早已建好。 </li>
</ol>
<h1 id="【实验代码】"><a href="#【实验代码】" class="headerlink" title="【实验代码】"></a>【实验代码】</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXVALUE 2147483647</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 27</span></span><br><span class="line"><span class="comment"> * 空格(需要你打一个真的空格，然后再输入后面的英文字母)ABCDEFGHIJKLMNOPQRSTUVWXYZ</span></span><br><span class="line"><span class="comment"> * 186 64 13 22 32 103 21 15 47 57 1 5 32 20 57 63 15 1 48 51 80 23 8 18 1 16 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data; <span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">int</span> weight; <span class="comment">// 权值</span></span><br><span class="line">    <span class="keyword">int</span> parent, lChild, rChild; <span class="comment">// 双亲位置，左孩子位置，右孩子位置</span></span><br><span class="line">    string code; <span class="comment">// 哈夫曼编码</span></span><br><span class="line">&#125; HTNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(HuffmanTree &amp;HT, <span class="keyword">int</span> &amp;n)</span></span>; <span class="comment">// 初始化哈夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StorageToHfmTree</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> m)</span></span>; <span class="comment">// 存储哈夫曼树到hfmtree文件中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HfmTreeToHuffmanTree</span><span class="params">(HuffmanTree &amp;HT,<span class="keyword">int</span> &amp;n)</span></span>; <span class="comment">// 从文件中读取哈夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree &amp;HT, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 为字符编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMinValue</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n, <span class="keyword">int</span> &amp;s1, <span class="keyword">int</span> &amp;s2)</span></span>; <span class="comment">// 获取此时结点中最小的两个</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoding</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n)</span></span>; <span class="comment">// 将文本编码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decoding</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> m)</span></span>; <span class="comment">// 将文本译码</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsLeaf</span><span class="params">(HTNode HN)</span></span>; <span class="comment">// 判断结点是否为叶子结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>; <span class="comment">// 输出编码后的文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreePrinting</span><span class="params">(HuffmanTree HT,<span class="keyword">int</span> count, <span class="keyword">int</span> index)</span></span>; <span class="comment">// 打印哈夫曼树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintT</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> count, <span class="keyword">int</span> index)</span></span>; <span class="comment">// 打印哈夫曼树</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">0</span>;</span><br><span class="line">    HuffmanTree HT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;\n菜单：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I：初始化哈夫曼树，将其存储在文件hfmTree中。         E：对文件ToBeTran中的文本进行编码，将结果储存在文件CodeFile中&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;D：将文件CodeFile中的数据进行译码，储存在文件TextFile中                     P：将文件CodeFile中的数据输出在终端上&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;T：将内存中的哈夫曼树按树形结果输出在终端上，同时将此树储存在文件TreePrint中   Q：退出程序&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请选择你要使用的功能：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;退出程序成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span>(ch)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;开始初始化哈夫曼树!&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">Initialization</span>(HT, N);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;初始化完成!&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span>(N == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">HfmTreeToHuffmanTree</span>(HT,N); <span class="comment">//如果内存中没有哈夫曼树，就从文件中读取</span></span><br><span class="line">                &#125;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;开始编码! &quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">Encoding</span>(HT, N);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;编码成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;开始译码! &quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">Decoding</span>(HT, <span class="number">2</span> * N - <span class="number">1</span>);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;译码成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;编码文件为! &quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">Print</span>();</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;\n编码文件打印完毕！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;T&#x27;</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;凹入表打印：&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="built_in">TreePrinting</span>(HT,<span class="number">0</span>,<span class="number">2</span>*N<span class="number">-1</span>);</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;打印完成！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;操作编码异常，请重新输入！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(HuffmanTree &amp;HT, <span class="keyword">int</span> &amp;n)</span> <span class="comment">// 初始化哈夫曼树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入字符集大小：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符集过小，初始化失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m = <span class="number">2</span> * n - <span class="number">1</span>; <span class="comment">// 哈夫曼树总结点数</span></span><br><span class="line">    HT = <span class="keyword">new</span> HTNode[m + <span class="number">1</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请依次输入你的字符集的字符：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">        <span class="keyword">if</span>(ch == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ch = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(ch == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ch = <span class="built_in">getchar</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        HT[i].data = ch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请依次输入你的字符集的各个字符所对应的权值：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> wei;</span><br><span class="line">        cin &gt;&gt; wei;</span><br><span class="line">        HT[i].weight = wei;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lChild = <span class="number">0</span>;</span><br><span class="line">        HT[i].rChild = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        HT[i].weight = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lChild = <span class="number">0</span>;</span><br><span class="line">        HT[i].rChild = <span class="number">0</span>;</span><br><span class="line">        HT[i].data = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s1, s2;</span><br><span class="line">        <span class="built_in">GetMinValue</span>(HT, i - <span class="number">1</span>, s1, s2);</span><br><span class="line">        HT[s1].parent = i;</span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lChild = s1;</span><br><span class="line">        HT[i].rChild = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">HuffmanCoding</span>(HT, n); <span class="comment">// 为字符编码</span></span><br><span class="line">    <span class="built_in">StorageToHfmTree</span>(HT, m); <span class="comment">// 将哈夫曼树存进文件中</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HfmTreeToHuffmanTree</span><span class="params">(HuffmanTree &amp;HT, <span class="keyword">int</span> &amp;n)</span> <span class="comment">// 从文件中读取哈夫曼树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;file/hfmTree.txt&quot;</span>, ios::in)</span></span>;</span><br><span class="line">    infile &gt;&gt; n;</span><br><span class="line">    HT = <span class="keyword">new</span> HTNode[<span class="number">2</span> * n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"></span><br><span class="line">        infile &gt;&gt; HT[i].weight &gt;&gt; HT[i].parent &gt;&gt; HT[i].lChild &gt;&gt; HT[i].rChild;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= n) &#123;</span><br><span class="line">            infile &gt;&gt; HT[i].data;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            HT[i].data = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line">    <span class="built_in">HuffmanCoding</span>(HT, n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StorageToHfmTree</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> m)</span> <span class="comment">// 存储哈夫曼树到hfmtree文件中</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;file/hfmTree.txt&quot;</span>, ios::out)</span></span>;</span><br><span class="line">    outfile &lt;&lt; (m + <span class="number">1</span>) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        outfile &lt;&lt; HT[i].weight &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; HT[i].parent &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; HT[i].lChild &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; HT[i].rChild;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= (m + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">            outfile &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; HT[i].data;</span><br><span class="line">        &#125;</span><br><span class="line">        outfile &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanCoding</span><span class="params">(HuffmanTree &amp;HT, <span class="keyword">int</span> n)</span> <span class="comment">// 为字符编码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i, f = HT[i].parent; f != <span class="number">0</span>; j = f, f = HT[f].parent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[f].lChild == j) &#123;</span><br><span class="line">                HT[i].code = <span class="string">&#x27;0&#x27;</span> + HT[i].code;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                HT[i].code = <span class="string">&#x27;1&#x27;</span> + HT[i].code;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMinValue</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n, <span class="keyword">int</span> &amp;s1, <span class="keyword">int</span> &amp;s2)</span> <span class="comment">// 获取此时结点中最小的两个</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s1 = s2 = MAXVALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s1 &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[s1].weight) &#123;</span><br><span class="line">                s1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; s1) &#123;</span><br><span class="line">                s1 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent != <span class="number">0</span> || i == s1) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s2 &lt;= n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[s2].weight &amp;&amp; HT[i].weight &gt; HT[s1].weight) &#123;</span><br><span class="line">                s2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; s2 &amp;&amp; HT[i].weight &gt;= HT[s1].weight) &#123;</span><br><span class="line">                s2 = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Encoding</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> n)</span> <span class="comment">// 将文本编码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str1, str2 = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;file/ToBeTran.txt&quot;</span>, ios::in)</span></span>;</span><br><span class="line"></span><br><span class="line">    ostringstream buf;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span>(buf &amp;&amp; infile.<span class="built_in">get</span>(ch))</span><br><span class="line">    &#123;</span><br><span class="line">        buf.<span class="built_in">put</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    str1 = buf.<span class="built_in">str</span>();</span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str1.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str1[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            str1[i] = <span class="string">&#x27;@&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[i] == HT[j].data) &#123;</span><br><span class="line">                str2 += HT[j].code;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;file/CodeFile.txt&quot;</span>, ios::out)</span></span>;</span><br><span class="line">    outfile &lt;&lt; str2;</span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Decoding</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> m)</span> <span class="comment">// 将哈夫曼编码译码</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string code = <span class="string">&quot;&quot;</span>, str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;file/CodeFile.txt&quot;</span>, ios::in)</span></span>;</span><br><span class="line">    infile &gt;&gt; code;</span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cur = m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= code.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsLeaf</span>(HT[cur])) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = HT[cur].data;</span><br><span class="line">            <span class="keyword">if</span>(ch == <span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ch = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            str += ch;</span><br><span class="line">            cur = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (code[i] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            cur = HT[cur].lChild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = HT[cur].rChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;file/TextFile.txt&quot;</span>, ios::out)</span></span>;</span><br><span class="line">    outfile &lt;&lt; str;</span><br><span class="line">    outfile.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsLeaf</span><span class="params">(HTNode HN)</span> <span class="comment">// 判断结点是否为叶子结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (HN.lChild == <span class="number">0</span> &amp;&amp; HN.rChild == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> <span class="comment">// 输出编码后的文件</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="function">ifstream <span class="title">infile</span><span class="params">(<span class="string">&quot;file/CodeFile.txt&quot;</span>, ios::in)</span></span>;</span><br><span class="line">    infile &gt;&gt; str;</span><br><span class="line">    infile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">ofstream <span class="title">outfile</span><span class="params">(<span class="string">&quot;file/CodePrin.txt&quot;</span>, ios::out)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; str[i];</span><br><span class="line">        outfile &lt;&lt; str[i];</span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">50</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">            outfile &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">outTree</span><span class="params">(<span class="string">&quot;file/TreePrint.txt&quot;</span>,ios::out)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TreePrinting</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> count, <span class="keyword">int</span> index)</span> <span class="comment">// 打印存储哈夫曼树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">PrintT</span>(HT,count,index);</span><br><span class="line">    outTree.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintT</span><span class="params">(HuffmanTree HT, <span class="keyword">int</span> count, <span class="keyword">int</span> index)</span> <span class="comment">// 打印哈夫曼树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">PrintT</span>(HT, count + <span class="number">1</span>, HT[index].rChild);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">            outTree &lt;&lt; <span class="string">&quot;    &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; HT[index].data &lt;&lt; endl;</span><br><span class="line">        outTree &lt;&lt; HT[index].data &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">PrintT</span>(HT, count + <span class="number">1</span>, HT[index].lChild);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="【最终效果】"><a href="#【最终效果】" class="headerlink" title="【最终效果】"></a>【最终效果】</h1><p><img src="https://img-blog.csdnimg.cn/20210128192200684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZ3JldA==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/2021012819244824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZ3JldA==,size_16,color_FFFFFF,t_70"></p>
]]></content>
      <categories>
        <category>数据结构实验</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实验二：线性表及其应用——约瑟夫环</title>
    <url>/2021/01/29/%E5%AE%9E%E9%AA%8C%E4%BA%8C%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/</url>
    <content><![CDATA[<h1 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h1><p>帮助学生熟练掌握线性表的基本操作在顺序和链式两种存储结构上的实现，其中以各种链表的操作和应用作为重点内容。</p>
<h1 id="【实验内容及要求】"><a href="#【实验内容及要求】" class="headerlink" title="【实验内容及要求】"></a>【实验内容及要求】</h1><ol>
<li>问题描述：约瑟夫问题的一种描述是：编号为1,2,…,n的n个人按顺时针方向围坐一圈，每人持有一个密码（正整数）。一开始任选一个正整数作为报数上限值m，从第一个人开始按顺时针方向自1开始顺序报数，报到m时停止报数。报m的人出列，将他的密码作为新的m的值，从他在顺时针方向上的下一个人开始重新从1报数，如此下去，直至所有人全部出列为止。试设计一个程序求出出列顺序。</li>
<li>基本要求：利用单向循环链表存储结构模拟此过程，按照出列的顺序印出各人的编号。</li>
<li>测试数据：m的初值为20；n=7，7个人的密码依次为：3,1,7,2,4,8,4,首先m值为6（正确的出列顺序应为6,1,4,7,2,3,5）。</li>
<li>实现提示：程序运行后，首先要求用户指定初始报数上限值，然后读取各人的密码。可设n≤30。此题所用的循环链表中不需要“头结点”，请注意空表和非空表的界限。</li>
</ol>
<h1 id="【实验代码】"><a href="#【实验代码】" class="headerlink" title="【实验代码】"></a>【实验代码】</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">circularList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">int</span> passward;</span><br><span class="line">    circularList *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">circularList * <span class="title">createList</span><span class="params">(<span class="keyword">int</span> n)</span></span>; <span class="comment">// 创建循环链表</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(circularList *)</span></span>; <span class="comment">// 获取链表长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(circularList *, circularList *)</span></span>; <span class="comment">// 获取指定元素索引</span></span><br><span class="line"><span class="function">circularList * <span class="title">deleteList</span><span class="params">(circularList *, <span class="keyword">int</span>)</span></span>; <span class="comment">// 删除结点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n; <span class="comment">// m为报数初始上限值，n为总人数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入报数初始上限值：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入参与报数的总人数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">1</span> || m &lt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;人数或初始报数值非法！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    circularList * josephRing;</span><br><span class="line">    josephRing = <span class="built_in">createList</span>(n);</span><br><span class="line">    circularList * head = josephRing;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getLength</span>(josephRing) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deleteList</span>(head,<span class="number">1</span>);</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;报数完毕！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            josephRing = josephRing-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        m = josephRing-&gt;passward;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">getIndex</span>(head,josephRing) == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            josephRing = head = <span class="built_in">deleteList</span>(head,<span class="built_in">getIndex</span>(head,josephRing));</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            josephRing = <span class="built_in">deleteList</span>(head,<span class="built_in">getIndex</span>(head,josephRing));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">circularList * <span class="title">createList</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">// 创建循环链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    circularList * head, * q, * p; <span class="comment">// q为了新建结点，p为了在各个结点中运行，head是链表头部结点</span></span><br><span class="line">    head = q = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请依次输入每个人的密码: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        q = <span class="keyword">new</span> circularList;</span><br><span class="line">        q-&gt;number = i + <span class="number">1</span>;</span><br><span class="line">        cin &gt;&gt; q-&gt;passward;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            head = q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;next = q;</span><br><span class="line">        &#125;</span><br><span class="line">        p = q;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;next = head;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;循环链表创建成功! &quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(circularList * head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    circularList * p = head;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;next == head)</span><br><span class="line">        &#123;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(circularList * head, circularList * jos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    circularList * p = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(p-&gt;next == head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p == jos)</span><br><span class="line">        &#123;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n++;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">circularList * <span class="title">deleteList</span><span class="params">(circularList * head, <span class="keyword">int</span> n)</span> <span class="comment">// 删除结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    circularList * p = head, * q; <span class="comment">// p为了在各个结点中运行，q为了储存要删除的结点，head是链表头部结点</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span> || n &gt; <span class="built_in">getLength</span>(head))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;索引超出范围，删除失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">getLength</span>(head) - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">        head = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p-&gt;next;</span><br><span class="line">        p-&gt;next = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; q-&gt;number &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;出列！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构实验</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实验六：图及其应用——图的遍历</title>
    <url>/2021/02/03/%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9A%E5%9B%BE%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h1><p>使学生深入了解图结构的特点，掌握创建图的各种存储结构的方法；同时深刻理解图的DFS和BFS遍历过程。</p>
<h1 id="【实验内容】"><a href="#【实验内容】" class="headerlink" title="【实验内容】"></a>【实验内容】</h1><ol>
<li>问题描述：很多涉及图上操作的算法都是以图的遍历操作为基础的。试写一个程序，演示在连通的无向图上访问全部结点的操作。</li>
<li>基本要求：以邻接表为存储结构，实现连通无向图的深度优先和广度优先遍历。分别输出每种遍历下的结点访问序列和相应生成树的边集。</li>
<li>实现提示：设图的结点不超过30个，每个结点用一个编号表示（如果一个图有n个结点，则它们的编号分别为1,2,…,n）。通过输入图的全部边输入一个图，每个边为一个数对，可以对边的输入顺序作出某种限制，注意，生成树的边是有向边，端点顺序不能颠倒。</li>
</ol>
<h1 id="【实验代码】"><a href="#【实验代码】" class="headerlink" title="【实验代码】"></a>【实验代码】</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 9 15</span></span><br><span class="line"><span class="comment">A B C D E F G H I</span></span><br><span class="line"><span class="comment">A B</span></span><br><span class="line"><span class="comment">A F</span></span><br><span class="line"><span class="comment">B G</span></span><br><span class="line"><span class="comment">G F</span></span><br><span class="line"><span class="comment">B C</span></span><br><span class="line"><span class="comment">B I</span></span><br><span class="line"><span class="comment">G D</span></span><br><span class="line"><span class="comment">G H</span></span><br><span class="line"><span class="comment">F E</span></span><br><span class="line"><span class="comment">C I</span></span><br><span class="line"><span class="comment">C D</span></span><br><span class="line"><span class="comment">I D</span></span><br><span class="line"><span class="comment">D H</span></span><br><span class="line"><span class="comment">D E</span></span><br><span class="line"><span class="comment">H E</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> // 队列</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    T value;</span><br><span class="line">    Queue&lt;T&gt; * next;</span><br><span class="line">    Queue&lt;T&gt; * front, * rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex; <span class="comment">// 邻接点下标</span></span><br><span class="line">    EdgeNode * next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    EdgeNode * firstEdge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Graph</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexNode * adjList;</span><br><span class="line">    <span class="keyword">int</span> numVertexs, numEdges; <span class="comment">// 顶点数，边数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(Queue&lt;T&gt; &amp;s)</span></span>; <span class="comment">// 初始化队列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(Queue&lt;T&gt; &amp;s, T e)</span></span>; <span class="comment">// 入列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(Queue&lt;T&gt; &amp;s, T &amp;e)</span></span>; <span class="comment">// 出列</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QEmpty</span><span class="params">(Queue&lt;T&gt; s)</span></span>; <span class="comment">// 判断队列是否为空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateALGraph</span><span class="params">(Graph * G)</span></span>; <span class="comment">// 创建图</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(Graph * G, <span class="keyword">char</span> ch)</span></span>; <span class="comment">// 寻找字符所在顶点的下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph * G, <span class="keyword">int</span> i)</span></span>; <span class="comment">// 深度优先搜索遍历递归处</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph * G)</span></span>; <span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph *G)</span></span>; <span class="comment">// 广度优先搜索</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Graph * G = <span class="keyword">new</span> Graph;</span><br><span class="line">    <span class="built_in">CreateALGraph</span>(G);</span><br><span class="line">    <span class="built_in">DFSTraverse</span>(G);</span><br><span class="line">    <span class="built_in">BFSTraverse</span>(G);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateALGraph</span><span class="params">(Graph * G)</span> <span class="comment">// 创建图</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numVexs, numEdges; <span class="comment">// 顶点数，边数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入顶点数和边数：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; numVexs &gt;&gt; numEdges;</span><br><span class="line"></span><br><span class="line">    G-&gt;adjList = <span class="keyword">new</span> VertexNode[numVexs];</span><br><span class="line">    G-&gt;numVertexs = numVexs;</span><br><span class="line">    G-&gt;numEdges = numEdges;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入你的图的顶点的数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numVertexs; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; G-&gt;adjList[i].data;</span><br><span class="line">        G-&gt;adjList[i].firstEdge = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入你的图中的边，输入格式只需输入这条边所连接的两个顶点，比如边(a,b)，只需输入：a b，即可。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numEdges; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> vex1, vex2; <span class="comment">// 边的两个端点</span></span><br><span class="line">        cin &gt;&gt; vex1 &gt;&gt; vex2;</span><br><span class="line">        <span class="keyword">int</span> index1, index2;</span><br><span class="line">        index1 = <span class="built_in">find</span>(G,vex1); <span class="comment">//顶点1的下标</span></span><br><span class="line">        index2 = <span class="built_in">find</span>(G,vex2); <span class="comment">//顶点2的下标</span></span><br><span class="line"></span><br><span class="line">        EdgeNode * e = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">        e-&gt;adjvex = index1;</span><br><span class="line">        e-&gt;next = G-&gt;adjList[index2].firstEdge;</span><br><span class="line">        G-&gt;adjList[index2].firstEdge = e;</span><br><span class="line"></span><br><span class="line">        e = <span class="keyword">new</span> EdgeNode;</span><br><span class="line">        e-&gt;adjvex = index2;</span><br><span class="line">        e-&gt;next = G-&gt;adjList[index1].firstEdge;</span><br><span class="line">        G-&gt;adjList[index1].firstEdge = e;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(Graph * G, <span class="keyword">char</span> ch)</span> <span class="comment">// 寻找字符所在顶点的下标</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numVertexs; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch == G-&gt;adjList[i].data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未在图中找到所要寻找的顶点！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> * visitedDFS; <span class="comment">// 深度优先搜索遍历数组标志</span></span><br><span class="line">string DFSSpanningTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(Graph * G, <span class="keyword">int</span> i)</span> <span class="comment">// 深度优先搜索遍历递归处</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EdgeNode * p =G-&gt;adjList[i].firstEdge;</span><br><span class="line">    visitedDFS[i] = <span class="literal">true</span>;</span><br><span class="line">    cout &lt;&lt; G-&gt;adjList[i].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visitedDFS[p-&gt;adjvex])</span><br><span class="line">        &#123;</span><br><span class="line">            DFSSpanningTree = DFSSpanningTree + <span class="string">&quot;(&quot;</span> + G-&gt;adjList[i].data + <span class="string">&quot;,&quot;</span> + G-&gt;adjList[p-&gt;adjvex].data + <span class="string">&quot;) &quot;</span>;</span><br><span class="line">            <span class="built_in">DFS</span>(G,p-&gt;adjvex);</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFSTraverse</span><span class="params">(Graph * G)</span> <span class="comment">// 深度优先搜索</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;深度优先搜索：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    visitedDFS = <span class="keyword">new</span> <span class="keyword">bool</span>[G-&gt;numVertexs];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numVertexs; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visitedDFS[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numVertexs; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visitedDFS[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">DFS</span>(G,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;边集：&quot;</span> &lt;&lt; DFSSpanningTree &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> * visitedBFS; <span class="comment">// 广度优先搜索遍历数组标志</span></span><br><span class="line">string BFSSpanningTree;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSTraverse</span><span class="params">(Graph *G)</span> <span class="comment">// 广度优先搜索</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;广度优先搜索：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; queue;</span><br><span class="line">    <span class="built_in">InitQueue</span>(queue);</span><br><span class="line"></span><br><span class="line">    visitedBFS = <span class="keyword">new</span> <span class="keyword">bool</span>[G-&gt;numVertexs];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numVertexs; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visitedBFS[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G-&gt;numVertexs; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visitedBFS[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visitedBFS[i] = <span class="literal">true</span>;</span><br><span class="line">            cout &lt;&lt; G-&gt;adjList[i].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="built_in">enQueue</span>(queue,i);</span><br><span class="line">            <span class="keyword">while</span>(!<span class="built_in">QEmpty</span>(queue))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">deQueue</span>(queue,i);</span><br><span class="line">                EdgeNode * p = G-&gt;adjList[i].firstEdge;</span><br><span class="line">                <span class="keyword">while</span>(p)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visitedBFS[p-&gt;adjvex])</span><br><span class="line">                    &#123;</span><br><span class="line">                        visitedBFS[p-&gt;adjvex] = <span class="literal">true</span>;</span><br><span class="line">                        cout &lt;&lt; G-&gt;adjList[p-&gt;adjvex].data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">                        BFSSpanningTree = BFSSpanningTree + <span class="string">&quot;(&quot;</span> + G-&gt;adjList[i].data + <span class="string">&quot;,&quot;</span> + G-&gt;adjList[p-&gt;adjvex].data + <span class="string">&quot;) &quot;</span>;</span><br><span class="line">                        <span class="built_in">enQueue</span>(queue,p-&gt;adjvex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = p-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;边集：&quot;</span> &lt;&lt; BFSSpanningTree &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitQueue</span><span class="params">(Queue&lt;T&gt; &amp;s)</span> <span class="comment">// 初始化队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.front = <span class="keyword">new</span> Queue&lt;T&gt;;</span><br><span class="line">    s.rear = s.front;</span><br><span class="line">    s.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(Queue&lt;T&gt; &amp;s, T e)</span> <span class="comment">// 入列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;T&gt; * p = <span class="keyword">new</span> Queue&lt;T&gt;;</span><br><span class="line">    p-&gt;value = e;</span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    s.rear-&gt;next = p;</span><br><span class="line">    s.rear = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deQueue</span><span class="params">(Queue&lt;T&gt; &amp;s, T &amp;e)</span> <span class="comment">// 出列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">QEmpty</span>(s))</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;队列为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e = s.front-&gt;next-&gt;value;<span class="comment">//获取数据并传递给e,头节点不存放数据</span></span><br><span class="line">    Queue&lt;T&gt; * p;</span><br><span class="line">    p = s.front-&gt;next;</span><br><span class="line">    s.front-&gt;next = s.front-&gt;next-&gt;next;<span class="comment">//指向下一块地址</span></span><br><span class="line">    <span class="keyword">if</span> (s.front-&gt;next == <span class="literal">NULL</span>)<span class="comment">//如果链队空了，则队尾指针指向队头指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        s.rear = s.front;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QEmpty</span><span class="params">(Queue&lt;T&gt; s)</span> <span class="comment">// 判断队列是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.front-&gt;next==<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构实验</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实验四：树及其应用——二叉树的遍历</title>
    <url>/2021/02/01/%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E6%A0%91%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h1><p>使学生深入了解并掌握非线性数据结构的特点，掌握创建二叉树二叉链表存储结构的方法；同时深刻理解二叉树的各遍历过程。</p>
<h1 id="【实验内容】"><a href="#【实验内容】" class="headerlink" title="【实验内容】"></a>【实验内容】</h1><ol>
<li>问题描述：很多涉及二叉树操作的算法都是以二叉树遍历为基础的。本实验要求编写程序，对一棵给定的二叉树进行先、中、后三种次序的遍历。</li>
<li>基本要求：以二叉链表为存储结构，实现二叉树的先、中、后三种次序的递归遍历。</li>
<li>实现提示：<br>（１）设二叉树的结点不超过30个，每个结点的数据均为字符，这样可用先序遍历序列作为输入，顺序创建二叉树链表存储结构。<br>（２）也可利用完全二叉树在顺序存储中的特性，创建二叉树的存储结构，此时，二叉树中结点数据的类型不受限制。</li>
<li>选作内容：<br>（1）以二叉链表为存储结构，实现二叉树的先、中、后三种次序的非递归遍历。<br>（2）借助队列，实现二叉树的层序遍历。<br>（3）按凹入表或树形打印所遍历的二叉树。</li>
</ol>
<h1 id="【实验代码】"><a href="#【实验代码】" class="headerlink" title="【实验代码】"></a>【实验代码】</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 前序遍历数据</span></span><br><span class="line"><span class="comment"> * AB#D##C##</span></span><br><span class="line"><span class="comment"> * ABDG##H###CE#I##F##</span></span><br><span class="line"><span class="comment"> * ABDH#K###E##CFI###G#J##</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    BiNode *lChild, *rChild;</span><br><span class="line">&#125; BiNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(BiTree &amp;T)</span></span>; <span class="comment">// 创建二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>; <span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>; <span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>; <span class="comment">// 后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nonRecursivePre</span><span class="params">(BiTree T)</span></span>; <span class="comment">//非递归前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nonRecursiveIn</span><span class="params">(BiTree T)</span></span>; <span class="comment">//非递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nonRecursivePost</span><span class="params">(BiTree T)</span></span>; <span class="comment">//非递归后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrderTraverse</span><span class="params">(BiTree T)</span></span>; <span class="comment">// 层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printT</span><span class="params">(BiTree T, <span class="keyword">int</span> n)</span></span>; <span class="comment">//凹入表打印树结构</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;创建二叉树，请输入前序遍历的树的数据：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">CreateTree</span>(T);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n前序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n中序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n后序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n非递归前序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">nonRecursivePre</span>(T);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n非递归中序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">nonRecursiveIn</span>(T);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n非递归后序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">nonRecursivePost</span>(T);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n层序遍历：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">levelOrderTraverse</span>(T);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n凹入表输出：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printT</span>(T, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(BiTree &amp;T)</span> <span class="comment">// 创建二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    cin &gt;&gt; ch;</span><br><span class="line">    <span class="keyword">if</span> (ch == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        T = <span class="keyword">new</span> BiNode;</span><br><span class="line">        <span class="keyword">if</span> (!T) &#123;</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;lChild);</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;rChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span> <span class="comment">//前序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; T-&gt;data;</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T-&gt;lChild);</span><br><span class="line">    <span class="built_in">PreOrderTraverse</span>(T-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> <span class="comment">// 中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;lChild);</span><br><span class="line">    cout &lt;&lt; T-&gt;data;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span> <span class="comment">// 后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T-&gt;lChild);</span><br><span class="line">    <span class="built_in">PostOrderTraverse</span>(T-&gt;rChild);</span><br><span class="line">    cout &lt;&lt; T-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nonRecursivePre</span><span class="params">(BiTree T)</span> <span class="comment">//非递归前序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode *p = T;</span><br><span class="line">    stack&lt;BiNode *&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p) <span class="comment">// 当p不为空时，一边打印，一边往左走</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; p-&gt;data;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;lChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) <span class="comment">//p为空，说明此时的子树的根节点和左子树都遍历完了，进入右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            p = p-&gt;rChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nonRecursiveIn</span><span class="params">(BiTree T)</span> <span class="comment">//非递归中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BiNode *p = T;</span><br><span class="line">    stack&lt;BiNode *&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() || p) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p) <span class="comment">// 当p不为空时，一边入栈，一边往左走</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p = p-&gt;lChild;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>()) <span class="comment">//p为空，说明此时左子树都遍历完了，走到了左边的最下端，需要出栈，进入右子树</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            cout &lt;&lt; p-&gt;data;</span><br><span class="line">            p = p-&gt;rChild; <span class="comment">//进入右子树，开始新遍历，一开始继续往左走</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">nonRecursivePost</span><span class="params">(BiTree T)</span> <span class="comment">//非递归后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;BiNode *&gt; s;</span><br><span class="line"></span><br><span class="line">    BiNode *pCur, *pLastVisit; <span class="comment">//pCur为当前访问的结点，pLastVisit为上一个访问的结点</span></span><br><span class="line">    pCur = T;</span><br><span class="line">    pLastVisit = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (pCur) <span class="comment">// 先入栈，到树的最左端</span></span><br><span class="line">    &#123;</span><br><span class="line">        s.<span class="built_in">push</span>(pCur);</span><br><span class="line">        <span class="comment">//pLastVisit = pCur;</span></span><br><span class="line">        pCur = pCur-&gt;lChild;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到此处，pCur为空，到了树的最左端</span></span><br><span class="line">    <span class="keyword">while</span> (!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        pCur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pCur-&gt;rChild == <span class="literal">NULL</span> || pCur-&gt;rChild == pLastVisit) <span class="comment">// 打印结点的前提是此结点无右子树或右子树已经被访问过了</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; pCur-&gt;data;</span><br><span class="line">            pLastVisit = pCur;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="comment">//if (pCur-&gt;lChild == pLastVisit)</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 若左子树被访问完，右边不符合上面的要求，则需要进入右子树，再开始遍历，记得一定不能有这个else-if的条件</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(pCur);</span><br><span class="line">            <span class="comment">//pLastVisit = pCur;</span></span><br><span class="line">            pCur = pCur-&gt;rChild;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (pCur) &#123;</span><br><span class="line">                s.<span class="built_in">push</span>(pCur);</span><br><span class="line">                <span class="comment">//pLastVisit = pCur;</span></span><br><span class="line">                pCur = pCur-&gt;lChild;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrderTraverse</span><span class="params">(BiTree T)</span> <span class="comment">// 层序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;BiNode *&gt; q;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        q.<span class="built_in">push</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        BiNode *p = q.<span class="built_in">front</span>();</span><br><span class="line">        cout &lt;&lt; p-&gt;data;</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lChild) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(p-&gt;lChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rChild) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(p-&gt;rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printT</span><span class="params">(BiTree T, <span class="keyword">int</span> n)</span> <span class="comment">//凹入表打印树结构</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">printT</span>(T-&gt;rChild, n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; T-&gt;data &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printT</span>(T-&gt;lChild, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构实验</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>实验七：简易图书管理模拟系统</title>
    <url>/2021/02/04/%E5%AE%9E%E9%AA%8C%E4%B8%83%EF%BC%9A%E7%AE%80%E6%98%93%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E6%A8%A1%E6%8B%9F%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="【实验目的】"><a href="#【实验目的】" class="headerlink" title="【实验目的】"></a>【实验目的】</h1><p>插入、查找和删除等数据操作在实际应用中非常普遍，通过设计和实现一个简易的图书管理系统，进一步提高学生对插入、查找和删除等操作的理解和应用能力。帮助学生理解和掌握线性表和平衡二叉树等数据结构的基本操作和实现方法，加强学生综合应用数据结构知识解决实际问题的水平和能力。</p>
<h1 id="【实验内容】"><a href="#【实验内容】" class="headerlink" title="【实验内容】"></a>【实验内容】</h1><ol>
<li><p>问题描述：一个简易图书管理的基本业务活动包括：对新购入一种书的采编入库、图书的借阅和归还等。</p>
</li>
<li><p>基本要求：<br>（1）每种书的登记内容至少包括书号、书名、著者、现存量和总库存量等五项。<br>（2）作为演示系统，不必使用文件存储书籍数据和借阅登记信息。我们要求各种书的数据用二叉排序树来存储，借阅登记信息采用顺序表—链表来存储。顺序表存储借阅者信息，链表存储借阅者所借的各种书籍信息。借阅登记信息的存储结构如下示意：<br><img src="https://img-blog.csdnimg.cn/20210128195620157.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZ3JldA==,size_16,color_FFFFFF,t_70"><br>需要实现的三种主要功能定义如下：<br>①采编入库：新购入一种书，经分类和确定书号之后登记到图书帐目中去。如果这种书在帐中已有，则只将该书的总库存量增加。<br>②借阅：如果一种书的现存量大于零，则借出一本，登记借阅者的图书证号和归还期限。<br>③归还：注销对借阅者的登记，改变该书的现存量（如果借阅者归还所有的书，则注销该借阅者的信息）。</p>
</li>
<li><p>测试数据：<br>入库书号：ISBN 7-302-02368-9，ISBN 978-7-115-16985-3/TP，ISBN 978-7-302-03314-1，ISBN7-115-10563-4/TP·3043，ISBN 978-7-121-07479-0，ISBN 978-7-115-18809-0/TP，ISBN 978-7-04-024246-1，ISBN 7-111-12886-9，ISBN 978-7-115-19601-9/TP，ISBN 7-900183-01-9。<br>借书证号为081716的借阅者，先借阅10种图书各一本，后归还图书ISBN 7-302-02368-9和ISBN 978-7-121-07479-0。<br>借书证号为081710的借阅者，先借阅图书ISBN 978-7-121-07479-0和ISBN 978-7-302-03314-110各一本，后归还图书ISBN 978-7-121-07479-0。<br>其余数据可自行设计。</p>
</li>
<li><p>实现提示：<br>（1）各种图书按登记的先后顺序入库（利用平衡二叉树实现动态查找表的插入），书号为图书的关键字。初始时，平衡二叉树为空树。<br>（2）借阅者借阅图书时，先检查借阅者有无超期未归还图书，如有，则不能借阅，如无，利用平衡二叉树实现动态查找表的查找，登记借阅信息。注意，按规定，同一种书不能重复借阅。</p>
</li>
</ol>
<h1 id="【实验代码】"><a href="#【实验代码】" class="headerlink" title="【实验代码】"></a>【实验代码】</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;string&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BorrowedBook</span> // 书</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string bookNumber; <span class="comment">// 书号</span></span><br><span class="line">    string deadLine; <span class="comment">// 归还期限</span></span><br><span class="line">    BorrowedBook *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> // 学生</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string studentNumber; <span class="comment">// 借书号</span></span><br><span class="line">    BorrowedBook *firstBook;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StudentBorrowedBook</span> // 学生借书</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Student *student; <span class="comment">// 借阅者数组</span></span><br><span class="line">    <span class="keyword">int</span> sum; <span class="comment">// 借阅者总数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Book</span> &#123;</span></span><br><span class="line">    string name; <span class="comment">// 书名</span></span><br><span class="line">    string bookNumber; <span class="comment">// 书号</span></span><br><span class="line">    string author; <span class="comment">// 作者</span></span><br><span class="line">    <span class="keyword">int</span> numNow; <span class="comment">// 现存量</span></span><br><span class="line">    <span class="keyword">int</span> numTotal; <span class="comment">//总存量</span></span><br><span class="line">    <span class="keyword">int</span> BF; <span class="comment">// 平衡因子</span></span><br><span class="line">    Book *lChild, *rChild; <span class="comment">// 左右孩子</span></span><br><span class="line">&#125; Book, *AVLBook;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertBook</span><span class="params">(AVLBook &amp;book, string bookNumber, <span class="keyword">bool</span> &amp;flag)</span></span>; <span class="comment">//插入新值,flag用于判定是否需要调整平衡因子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(StudentBorrowedBook &amp;stu, string studentNumber)</span></span>;<span class="comment">//添加新学生</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsExistStu</span><span class="params">(StudentBorrowedBook stu, string numberStu)</span></span>; <span class="comment">// 判断是否存在此学生</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findStudent</span><span class="params">(StudentBorrowedBook stu, string numberStu, Student &amp;res)</span></span>; <span class="comment">// 寻找学生</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchTreeBorrow</span><span class="params">(AVLBook book, StudentBorrowedBook &amp;stu, Student &amp;student, string bookNumber, string time)</span></span>; <span class="comment">// 寻找书并借书</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchTreeReturn</span><span class="params">(AVLBook book, StudentBorrowedBook &amp;stu, Student &amp;student, string bookNumber)</span></span>; <span class="comment">// 寻找书并还书</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(StudentBorrowedBook stu)</span></span>; <span class="comment">// 描述借阅登记信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(AVLBook T)</span></span>; <span class="comment">// 中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printT</span><span class="params">(AVLBook T, <span class="keyword">int</span> n)</span></span>; <span class="comment">//凹入表打印树结构</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AVLBook book = <span class="literal">NULL</span>;</span><br><span class="line">    StudentBorrowedBook stu;</span><br><span class="line">    stu.sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;请问您要做什么，入库书籍请按P，借书请按B，还书请按R，退出系统请按Q：&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">        cin &gt;&gt; ch;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;退出程序成功！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in"><span class="keyword">switch</span></span> (ch) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>: &#123; <span class="comment">// 入库</span></span><br><span class="line">                <span class="keyword">bool</span> flag;</span><br><span class="line">                <span class="keyword">int</span> bookSum;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;请问您要入库几本书：&quot;</span> &lt;&lt; endl;</span><br><span class="line">                cin &gt;&gt; bookSum;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookSum; i++) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;请输入第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;本书的书号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    string bookNumber;</span><br><span class="line">                    <span class="built_in">getchar</span>();</span><br><span class="line">                    <span class="built_in">getline</span>(cin,bookNumber);</span><br><span class="line">                    <span class="comment">//cin &gt;&gt; bookNumber;</span></span><br><span class="line">                    <span class="built_in">InsertBook</span>(book, bookNumber, flag);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>: &#123; <span class="comment">// 借书</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;请输入你的借书证号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">                string studentNum;</span><br><span class="line">                cin &gt;&gt; studentNum;</span><br><span class="line">                <span class="built_in">getchar</span>();</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;请输入你要借的书的书号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">                string bookNumber;</span><br><span class="line">                <span class="built_in">getline</span>(cin,bookNumber);</span><br><span class="line">                <span class="comment">//cin &gt;&gt; bookNumber;</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">IsExistStu</span>(stu, studentNum)) <span class="comment">// 不存在此学生</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">addStudent</span>(stu, studentNum); <span class="comment">// 新建并添加此学生</span></span><br><span class="line">                &#125;</span><br><span class="line">                Student nowStu;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">findStudent</span>(stu, studentNum,nowStu))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">SearchTreeBorrow</span>(book, stu, nowStu, bookNumber, <span class="string">&quot;9&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>: &#123; <span class="comment">// 还书</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;请输入你的借书证号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">                string studentNum;</span><br><span class="line">                cin &gt;&gt; studentNum;</span><br><span class="line">                <span class="built_in">getchar</span>();</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;请输入你要还的书的书号：&quot;</span> &lt;&lt; endl;</span><br><span class="line">                string bookNumber;</span><br><span class="line">                <span class="built_in">getline</span>(cin,bookNumber);</span><br><span class="line">                <span class="comment">//cin &gt;&gt; bookNumber;</span></span><br><span class="line"></span><br><span class="line">                Student nowStu;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">findStudent</span>(stu, studentNum,nowStu))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">SearchTreeReturn</span>(book, stu, nowStu, bookNumber);</span><br><span class="line">                &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;查无此人，无法还书！&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;输入的功能代码错误，请重新输入！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n借阅人的信息有：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">display</span>(stu); <span class="comment">// 打印借阅人信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历平衡二叉树：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(book);<span class="comment">//中序遍历平衡二叉树</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;\n凹入表打印平衡二叉树：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printT</span>(book, <span class="number">0</span>); <span class="comment">//凹入表打印平衡二叉树</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">R_Rotate</span><span class="params">(AVLBook &amp;book)</span> <span class="comment">// 右旋 顺时针旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLBook tmp = book-&gt;lChild;</span><br><span class="line">    book-&gt;lChild = tmp-&gt;rChild;</span><br><span class="line">    tmp-&gt;rChild = book;</span><br><span class="line">    book = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">L_Rotate</span><span class="params">(AVLBook &amp;book)</span> <span class="comment">//左旋，逆时针旋转</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLBook tmp = book-&gt;rChild;</span><br><span class="line">    book-&gt;rChild = tmp-&gt;lChild;</span><br><span class="line">    tmp-&gt;lChild = book;</span><br><span class="line">    book = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leftBalance</span><span class="params">(AVLBook &amp;book)</span> <span class="comment">//左边失衡调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLBook lchild = book-&gt;lChild;</span><br><span class="line">    AVLBook tmpRightChild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (lchild-&gt;BF) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:                                                                     <span class="comment">//LL型失衡</span></span><br><span class="line">            book-&gt;BF = lchild-&gt;BF = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">R_Rotate</span>(book);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:                                                                    <span class="comment">//LR型失衡</span></span><br><span class="line">            tmpRightChild = lchild-&gt;rChild;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (tmpRightChild-&gt;BF) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    book-&gt;BF = <span class="number">-1</span>;</span><br><span class="line">                    lchild-&gt;BF = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    book-&gt;BF = lchild-&gt;BF = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                    book-&gt;BF = <span class="number">0</span>;</span><br><span class="line">                    lchild-&gt;BF = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpRightChild-&gt;BF = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">L_Rotate</span>(book-&gt;lChild);</span><br><span class="line">            <span class="built_in">R_Rotate</span>(book);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rightBalance</span><span class="params">(AVLBook &amp;book)</span> <span class="comment">//右边失衡调整</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLBook rightchild = book-&gt;rChild;</span><br><span class="line">    AVLBook tmpChild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (rightchild-&gt;BF) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">-1</span>:                                                                          <span class="comment">//RR型失衡</span></span><br><span class="line">            book-&gt;BF = rightchild-&gt;BF = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">L_Rotate</span>(book);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:                                                                         <span class="comment">//RL型失衡</span></span><br><span class="line">            tmpChild = rightchild-&gt;lChild;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (tmpChild-&gt;BF) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    book-&gt;BF = <span class="number">0</span>;</span><br><span class="line">                    rightchild-&gt;BF = <span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    book-&gt;BF = rightchild-&gt;BF = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                    book-&gt;BF = <span class="number">0</span>;</span><br><span class="line">                    rightchild-&gt;BF = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tmpChild-&gt;BF = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">R_Rotate</span>(book-&gt;rChild);</span><br><span class="line">            <span class="built_in">L_Rotate</span>(book);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLBook <span class="title">createBook</span><span class="params">(string bookNumber)</span> <span class="comment">//新建一个书节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLBook newBook = <span class="keyword">new</span> Book;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入书名：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; newBook-&gt;name;</span><br><span class="line">    newBook-&gt;bookNumber = bookNumber;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入作者：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; newBook-&gt;author;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入总存量：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cin &gt;&gt; newBook-&gt;numTotal;</span><br><span class="line"></span><br><span class="line">    newBook-&gt;numNow = newBook-&gt;numTotal;</span><br><span class="line">    newBook-&gt;BF = <span class="number">0</span>;</span><br><span class="line">    newBook-&gt;lChild = <span class="literal">NULL</span>;</span><br><span class="line">    newBook-&gt;rChild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newBook;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InsertBook</span><span class="params">(AVLBook &amp;book, string bookNumber, <span class="keyword">bool</span> &amp;flag)</span> <span class="comment">//插入新值,flag用于判定是否需要调整平衡因子</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (book == <span class="literal">NULL</span>) &#123;                                    <span class="comment">//树中不包含此键值，则新建一个节点，</span></span><br><span class="line">        book = <span class="built_in">createBook</span>(bookNumber);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (book-&gt;bookNumber == bookNumber) &#123;                <span class="comment">//树中已经包含此键值，则不需要插入</span></span><br><span class="line">        book-&gt;numNow++; <span class="comment">// 现存量+1</span></span><br><span class="line">        book-&gt;numTotal++; <span class="comment">// 总存量+1</span></span><br><span class="line">        flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bookNumber &lt; book-&gt;bookNumber) &#123;                  <span class="comment">//插入到左子树中</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">InsertBook</span>(book-&gt;lChild, bookNumber, flag))   <span class="comment">//如果左子树中存在该节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (book-&gt;BF) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="built_in">leftBalance</span>(book);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                    book-&gt;BF = <span class="number">0</span>;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    book-&gt;BF = <span class="number">1</span>;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">InsertBook</span>(book-&gt;rChild, bookNumber, flag))   <span class="comment">//如果右子树中存在该节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="built_in"><span class="keyword">switch</span></span> (book-&gt;BF) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    book-&gt;BF = <span class="number">0</span>;</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">                    <span class="built_in">rightBalance</span>(book);</span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    book-&gt;BF = <span class="number">-1</span>;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(StudentBorrowedBook &amp;stu, string studentNumber)</span> <span class="comment">//添加新学生</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Student *newStu = <span class="keyword">new</span> Student[stu.sum + <span class="number">1</span>];</span><br><span class="line">    Student *oldStu = stu.student;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stu.sum; i++) &#123;</span><br><span class="line">        newStu[i] = stu.student[i];</span><br><span class="line">    &#125;</span><br><span class="line">    newStu[stu.sum].studentNumber = studentNumber;</span><br><span class="line">    newStu[stu.sum].firstBook = <span class="keyword">new</span> BorrowedBook;</span><br><span class="line">    newStu[stu.sum].firstBook-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    stu.student = newStu;</span><br><span class="line">    stu.sum++;</span><br><span class="line">    <span class="comment">//delete[] oldStu;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsExistStu</span><span class="params">(StudentBorrowedBook stu, string numberStu)</span> <span class="comment">// 判断是否存在此学生</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stu.sum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stu.student[i].studentNumber == numberStu) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findStudent</span><span class="params">(StudentBorrowedBook stu, string numberStu, Student &amp;res)</span> <span class="comment">// 寻找学生</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stu.sum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stu.student[i].studentNumber == numberStu) &#123;</span><br><span class="line">            res = stu.student[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsBook</span><span class="params">(Student stu, string bookNumber)</span> <span class="comment">// 判断此学生是否借过此书</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BorrowedBook *p = stu.firstBook-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;bookNumber == bookNumber) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;此学生借过此书了！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsOverTime</span><span class="params">(BorrowedBook *book, string time)</span> <span class="comment">// 判断是否超过借书日期</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> time &lt; book-&gt;deadLine;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsStuBookOverTime</span><span class="params">(Student stu, string time)</span> <span class="comment">// 判断是否超过借书日期</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BorrowedBook *p = stu.firstBook-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">IsOverTime</span>(p, time)) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;有超时未归还的图书，不允许借书！&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BorrowBook</span><span class="params">(Student &amp;stu, string bookNumber)</span> <span class="comment">// 借阅一本书</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入归还日期：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    string deadLine;</span><br><span class="line">    cin &gt;&gt; deadLine;</span><br><span class="line"></span><br><span class="line">    BorrowedBook *newBook = <span class="keyword">new</span> BorrowedBook;</span><br><span class="line">    newBook-&gt;bookNumber = bookNumber;</span><br><span class="line">    newBook-&gt;deadLine = deadLine;</span><br><span class="line"></span><br><span class="line">    newBook-&gt;next = stu.firstBook-&gt;next;</span><br><span class="line">    stu.firstBook-&gt;next = newBook;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ReturnBook</span><span class="params">(Student &amp;stu, string bookNumber)</span> <span class="comment">// 归还一本书</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BorrowedBook *delBook, *p = stu.firstBook-&gt;next, *q = stu.firstBook;</span><br><span class="line">    <span class="keyword">while</span> (p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;bookNumber == bookNumber) &#123;</span><br><span class="line">            q-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        q = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteStudent</span><span class="params">(StudentBorrowedBook &amp;stu, string studentNum)</span> <span class="comment">// 删除一个学生</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stu.sum; i++) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (stu.student[i].studentNumber == studentNum) &#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; stu.sum; j++) &#123;</span><br><span class="line">                stu.student[j - <span class="number">1</span>] = stu.student[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stu.sum--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchTreeBorrow</span><span class="params">(AVLBook book, StudentBorrowedBook &amp;stu, Student &amp;student, string bookNumber, string time)</span> <span class="comment">// 寻找书并借书</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (book-&gt;bookNumber == bookNumber) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (book-&gt;numNow &gt; <span class="number">0</span>) <span class="comment">// 如果此书库存大于0</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">IsStuBookOverTime</span>(student, time)) <span class="comment">// 如果此借阅者没有超期未归还的书</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">IsBook</span>(student, book-&gt;bookNumber)) <span class="comment">// 如果此学生没有借过此书</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">BorrowBook</span>(student, book-&gt;bookNumber);</span><br><span class="line">                    book-&gt;numNow--;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;学生&quot;</span> &lt;&lt; student.studentNumber &lt;&lt; <span class="string">&quot;借了一本《&quot;</span> &lt;&lt; book-&gt;name &lt;&lt; <span class="string">&quot;》，作者为&quot;</span> &lt;&lt; book-&gt;author;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;，书号为：&quot;</span> &lt;&lt; book-&gt;bookNumber &lt;&lt; <span class="string">&quot;。库存&quot;</span> &lt;&lt; book-&gt;numTotal &lt;&lt; <span class="string">&quot;本，现存&quot;</span>;</span><br><span class="line">                    cout &lt;&lt; book-&gt;numNow &lt;&lt; <span class="string">&quot;本&quot;</span> &lt;&lt; endl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;此书已经被借阅完，无余书！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bookNumber &gt; book-&gt;bookNumber &amp;&amp; book-&gt;rChild) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchTreeBorrow</span>(book-&gt;rChild, stu,student, bookNumber, time);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bookNumber &lt; book-&gt;bookNumber &amp;&amp; book-&gt;lChild) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchTreeBorrow</span>(book-&gt;lChild, stu,student, bookNumber, time);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此书！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (student.firstBook-&gt;next == <span class="literal">NULL</span>) <span class="comment">// 如果此学生的所借书为零，那么删除此学生</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">deleteStudent</span>(stu, student.studentNumber);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchTreeReturn</span><span class="params">(AVLBook book, StudentBorrowedBook &amp;stu, Student &amp;student, string bookNumber)</span> <span class="comment">// 寻找书并还书</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (book-&gt;bookNumber == bookNumber) &#123; <span class="comment">// 找到书</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ReturnBook</span>(student, book-&gt;bookNumber)) <span class="comment">// 还书</span></span><br><span class="line">        &#123;</span><br><span class="line">            book-&gt;numNow++; <span class="comment">// 图书馆书现储备量增加</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;学生&quot;</span> &lt;&lt; student.studentNumber &lt;&lt; <span class="string">&quot;还了一本《&quot;</span> &lt;&lt; book-&gt;name &lt;&lt; <span class="string">&quot;》，作者为&quot;</span> &lt;&lt; book-&gt;author;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;，书号为：&quot;</span> &lt;&lt; book-&gt;bookNumber &lt;&lt; <span class="string">&quot;。库存&quot;</span> &lt;&lt; book-&gt;numTotal &lt;&lt; <span class="string">&quot;本，现存&quot;</span>;</span><br><span class="line">            cout &lt;&lt; book-&gt;numNow &lt;&lt; <span class="string">&quot;本&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (student.firstBook-&gt;next == <span class="literal">NULL</span>) <span class="comment">// 如果此学生的所借书为零，那么删除此学生</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">deleteStudent</span>(stu, student.studentNumber);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;此学生未借此书，无法归还！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bookNumber &gt; book-&gt;bookNumber &amp;&amp; book-&gt;rChild) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchTreeReturn</span>(book-&gt;rChild, stu, student, bookNumber);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bookNumber &lt; book-&gt;bookNumber &amp;&amp; book-&gt;lChild) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SearchTreeReturn</span>(book-&gt;lChild, stu, student, bookNumber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;查无此书！&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(StudentBorrowedBook stu)</span> <span class="comment">// 描述借阅登记信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stu.sum; i++) &#123;</span><br><span class="line">        BorrowedBook *p = stu.student[i].firstBook-&gt;next;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;此人借书号为：&quot;</span> &lt;&lt; stu.student[i].studentNumber &lt;&lt; <span class="string">&quot;   所借书籍的书号有：  &quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (p) &#123;</span><br><span class="line">            cout &lt;&lt; p-&gt;bookNumber &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(AVLBook T)</span> <span class="comment">// 中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;lChild);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;书号：&quot;</span> &lt;&lt; T-&gt;bookNumber &lt;&lt; <span class="string">&quot;  现存量：&quot;</span> &lt;&lt; T-&gt;numNow &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">    <span class="built_in">InOrderTraverse</span>(T-&gt;rChild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printT</span><span class="params">(AVLBook T, <span class="keyword">int</span> n)</span> <span class="comment">//凹入表打印树结构</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (T) &#123;</span><br><span class="line">        <span class="built_in">printT</span>(T-&gt;rChild, n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            cout &lt;&lt; T-&gt;bookNumber &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printT</span>(T-&gt;lChild, n + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构实验</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
