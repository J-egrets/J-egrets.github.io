<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>多线程笔记 | Egret's Blog</title><meta name="keywords" content="Java 多线程"><meta name="author" content="Egret"><meta name="copyright" content="Egret"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="记录了我学习多线程时的一些demo和知识点，以备今后回顾之用">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程笔记">
<meta property="og:url" content="https://jegret.cn/2021/05/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Egret&#39;s Blog">
<meta property="og:description" content="记录了我学习多线程时的一些demo和知识点，以备今后回顾之用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/08/16/MfkZmv3NWYtocyF.jpg">
<meta property="article:published_time" content="2021-05-16T13:05:49.000Z">
<meta property="article:modified_time" content="2022-01-19T10:20:26.999Z">
<meta property="article:author" content="Egret">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/08/16/MfkZmv3NWYtocyF.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://jegret.cn/2021/05/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":30,"position":"top","messagePrev":"该文章创建于","messageNext":"天前，请以最新文章为准"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":10,"languages":{"author":"作者: Egret","link":"链接: ","source":"来源: Egret's Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '多线程笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-19 18:20:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link rel="stylesheet" href="/css/icon.css" media="defer" onload="this.media='all'"><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/08/16/MfkZmv3NWYtocyF.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Egret's Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand hide"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">多线程笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-16T13:05:49.000Z" title="发表于 2021-05-16 21:05:49">2021-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-19T10:20:26.999Z" title="更新于 2022-01-19 18:20:26">2022-01-19</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">18.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>66分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="多线程笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本人学习多线程时做的一些笔记，以备以后回顾复习。</p>
<h1 id="第一章、多线程"><a href="#第一章、多线程" class="headerlink" title="第一章、多线程"></a>第一章、多线程</h1><h2 id="1-1-并发与并行"><a href="#1-1-并发与并行" class="headerlink" title="1.1 并发与并行"></a>1.1 并发与并行</h2><ul>
<li><strong>并发</strong>：指两个或多个事件在<strong>同一个时间段内</strong>发生。</li>
</ul>
<p>此时有两个任务，一个任务1，一个任务2，我要在某个时间内让它完成两个任务，一个任务1，一个任务2，我们用并发的方式完成，我们执行任务需要cpu来执行它，比如此时我的电脑是单核心的，它会先执行任务1再执行任务2，然后执行任务1<strong>比如（QQ，微信，浏览器，交替执行，但是交替速度很快）</strong>。这个指的就是并发即一段时间内，cpu在多个任务之间交替执行</p>
<p><img src="https://img-blog.csdnimg.cn/e162e972c1704b0ca53d27b4230a12bc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZ3JldA==,size_16,color_FFFFFF,t_70"></p>
<ul>
<li><strong>并行</strong>：指两个或多个事件在<strong>同一时刻</strong>发生（同时发生）。</li>
</ul>
<p>我们现在电脑的cpu都是多核心多线程的了对吧。这个cpu可以执行任务1，还能再来一个cpu让它执行任务2.所以这个并行它叫同时执行</p>
<p><img src="https://img-blog.csdnimg.cn/b7b8b3c7a08a40f09122614ad6cba6f4.png"></p>
<p>在操作系统中，安装了多个程序，并发指的是在一段时间内宏观上有多个程序同时运行，这在单 CPU 系统中，每一时刻只能有一道程序执行，即微观上这些程序是分时的交替运行，只不过是给人的感觉是同时运行，那是因为分时交替运行的时间是非常短的。</p>
<p>而在多个 CPU 系统中，则这些可以并发执行的程序便可以分配到多个处理器上（CPU），实现多任务并行执行，即利用每个处理器来处理一个可以并发执行的程序，这样多个程序便可以同时执行。目前电脑市场上说的多核 CPU，便是多核处理器，核越多，并行处理的程序越多，能大大的提高电脑运行的效率。</p>
<blockquote>
<p>注意：单核处理器的计算机肯定是不能并行的处理多个任务的，只能是多个任务在单个CPU上并发运行。同理，线程也是一样的，从宏观角度上理解线程是并行运行的，但是从微观角度上分析却是串行运行的，即一个线程一个线程的去运行，当系统只有一个CPU时，线程会以某种顺序执行多个线程，我们把这种情况称之为线程调度。</p>
</blockquote>
<h2 id="1-2-线程与进程"><a href="#1-2-线程与进程" class="headerlink" title="1.2 线程与进程"></a>1.2 线程与进程</h2><ul>
<li><p><strong>进程</strong>：是指一个内存中运行的应用程序，每个进程都有一个独立的内存空间，一个应用程序可以同时运行多个进程；进程也是程序的一次执行过程，是系统运行程序的基本单位；系统运行一个程序即是一个进程从创建、运行到消亡的过程。</p>
</li>
<li><p><strong>线程</strong>：线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。 </p>
<p>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程 </p>
</li>
</ul>
<p>我们可以再电脑底部任务栏，右键—–&gt;打开任务管理器,可以查看当前任务的进程：</p>
<p><strong>进程与线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	程序：一堆命令的集合，进程静止的状态，包括了可执行文件、配置文件、</span></span><br><span class="line"><span class="comment"> * 		   数据文件等等软件文件集合，即计算机要执行的任务。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	进程： 即具有一定功能的程序 关于某个数据集合上的一次运行活动，</span></span><br><span class="line"><span class="comment"> *       是cpu进行资源分配和调用的 一个独立单元。</span></span><br><span class="line"><span class="comment"> * 		 </span></span><br><span class="line"><span class="comment"> * 	线程： 有时候可以看成轻量级的进程，是程序执行流的最小单元，</span></span><br><span class="line"><span class="comment"> * 		  一个进程可以看做是有n个线程组成的</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		在单个程序运行的过程中，可以同时执行多个线程完成不同的工作，</span></span><br><span class="line"><span class="comment"> * 	    称之为多线程</span></span><br><span class="line"><span class="comment"> *	</span></span><br><span class="line"><span class="comment"> *	以腾讯管家为例，打开腾讯管家，就会进入到内存中，就是一个进程</span></span><br><span class="line"><span class="comment"> *	它里面有很多功能,例如病毒查杀，清理垃圾，电脑加速，他们都是一个线程</span></span><br><span class="line"><span class="comment"> *	此时点击病毒查杀，清理垃圾，电脑加速让它执行，它就会开启一条应用程序到cpu的执行路径</span></span><br><span class="line"><span class="comment"> *	cpu就可以通过路径就可以执行功能，这个路径有个名字叫线程 </span></span><br><span class="line"><span class="comment"> *	腾讯电脑管家实际上是个多线程的路径</span></span><br><span class="line"><span class="comment"> *	</span></span><br><span class="line"><span class="comment"> *	注意：线程是属于进程的，是进程中的一个执行单元，负责程序的执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> *	并发：</span></span><br><span class="line"><span class="comment"> *		 官方解释 ：并发，在操作系统中，是指一个时间段中有几个程序都处</span></span><br><span class="line"><span class="comment"> *				于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，</span></span><br><span class="line"><span class="comment"> *				但任一个时刻点上只有一个程序在处理机上运行。</span></span><br><span class="line"><span class="comment"> *	理解： </span></span><br><span class="line"><span class="comment"> * 	  线程总是并发运行的，操作系统会将时间分成若干个片段（时间片）</span></span><br><span class="line"><span class="comment"> * 	  尽可能的将这些时间片分配均匀的分配给每一个线程，</span></span><br><span class="line"><span class="comment"> *  	 当线程得到时间片以后，就可能被cpu所执行，</span></span><br><span class="line"><span class="comment"> *   	随着cpu高速的运行，从宏观的角度来看， 所有任务都在同时被执行，</span></span><br><span class="line"><span class="comment"> *   	但是从微观的角度看，每个任务都是走走停停的，此种现象被称为并发。</span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *   </span></span><br><span class="line"><span class="comment"> *	并行： 多个任务是被多个cpu真的同时运行。		</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>线程调度:</strong></p>
<ul>
<li><p>分时调度</p>
<p>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间</p>
</li>
<li><p>抢占式调度</p>
<p>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</p>
<ul>
<li><p>设置线程的优先级 </p>
</li>
<li><p>抢占式调度详解</p>
<p>大部分操作系统都支持多进程并发运行，现在的操作系统几乎都支持同时运行多个程序。比如：现在我们上课一边使用编辑器，一边使用录屏软件，同时还开着画图板，dos窗口等软件。此时，这些程序是在同时运行，”感觉这些软件好像在同一时刻运行着“。</p>
</li>
</ul>
<p>实际上，CPU(中央处理器)使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉要快，看上去就是在同一时刻运行。<br>  其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</p>
</li>
</ul>
<h2 id="1-3-创建线程类"><a href="#1-3-创建线程类" class="headerlink" title="1.3 创建线程类"></a>1.3 创建线程类</h2><p>Java使用<code>java.lang.Thread</code>类代表<strong>线程</strong>，所有的线程对象都必须是Thread类或其子类的实例。每个线程的作用是完成一定的任务，实际上就是执行一段程序流即一段顺序执行的代码。Java使用线程执行体来代表这段程序流。Java中通过继承Thread类来<strong>创建</strong>并<strong>启动多线程</strong>的步骤如下：</p>
<ol>
<li>定义Thread类的子类，并重写该类的run()方法，该run()方法的方法体就代表了线程需要完成的任务,因此把run()方法称为线程执行体。</li>
<li>创建Thread子类的实例，即创建了线程对象</li>
<li>调用线程对象的start()方法来启动该线程</li>
</ol>
<p>代码如下：</p>
<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建多线程程序的第一种方式:创建Thread类的子类</span></span><br><span class="line"><span class="comment">java.lang.Thread类:是描述线程的类,我们想要实现多线程程序,就必须继承Thread类</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">实现步骤:</span></span><br><span class="line"><span class="comment">    1.创建一个Thread类的子类</span></span><br><span class="line"><span class="comment">    2.在Thread类的子类中重写Thread类中的run方法,设置线程任务(开启线程要做什么?)</span></span><br><span class="line"><span class="comment">    3.创建Thread类的子类对象</span></span><br><span class="line"><span class="comment">    4.调用Thread类中的方法start方法,开启新的线程,执行run方法</span></span><br><span class="line"><span class="comment">         void start() 使该线程开始执行；Java 虚拟机调用该线程的 run 方法。</span></span><br><span class="line"><span class="comment">         结果是两个线程并发地运行；当前线程（main线程）和另一个线程（创建的新线程,执行其 run 方法）。</span></span><br><span class="line"><span class="comment">         多次启动一个线程是非法的。特别是当线程已经结束执行后，不能再重新启动。</span></span><br><span class="line"><span class="comment">java程序属于抢占式调度,那个线程的优先级高,那个线程优先执行;同一个优先级,随机选择一个执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 3.创建Thread类的子类对象</span></span><br><span class="line">		MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">		<span class="comment">// 4.调用Thread类中的方法start方法,开启新的线程,执行run方法</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 注：  启动一个线程，是通过调用其start()来实现的。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		mt.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;main:&quot;</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义线程类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">//定义指定线程名称的构造方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//调用父类的String参数的构造方法，指定线程的名称</span></span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 重写run方法，完成该线程执行的逻辑</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">			System.out.println(getName()+<span class="string">&quot;：正在执行！&quot;</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第二章、多线程执行原理"><a href="#第二章、多线程执行原理" class="headerlink" title="第二章、多线程执行原理"></a>第二章、多线程执行原理</h1><p>JVM执行main方法，找os开辟一条main方法通向CPU的路径，这个路径叫做main线程(主线程)</p>
<p>cpu通过这个线程,这个路径可以执行main方法</p>
<p>当我们在这里new MyThread(); 等于它重新开辟了一个指向CPU的路径</p>
<p>这条路径是执行run方法的</p>
<p>现在对于CPU而言,我是不是有两条执行路径了，cpu就有了选择的权限。</p>
<p>注意：我们控制不了CPU，CPU喜欢谁它就会执行哪条路径</p>
<p><img src="https://img-blog.csdnimg.cn/d1a6b8d67da0453ab3e70912742dad0b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZ3JldA==,size_16,color_FFFFFF,t_70"></p>
<p><strong>所以就有了程序的随机打印结果</strong></p>
<p>即两个线程，一个main线程，一个thread线程一起抢夺cpu的执行权(cpu的执行时间)</p>
<p>谁抢到了谁执行对应的代码。<br><img src="https://img-blog.csdnimg.cn/1efe066342804fbeb8b15af5b86e6d88.png"></p>
<h2 id="2-1、多线程原理"><a href="#2-1、多线程原理" class="headerlink" title="2.1、多线程原理"></a>2.1、多线程原理</h2><p>有一个main方法，还有一个run方法。run方法里面有个for循环，</p>
<p>那我们来看看它的内存图解</p>
<p>首先它有一个栈内存</p>
<p>程序怎么执行的呢，首先执行程序的入口也就是main方法。它会压栈执行，从栈内存进来跑到栈内存最下面来</p>
<p>然后一行行执行代码，首先创建对象，对象创建在那里?是不是就是在堆内存中，这里new的对象是在堆内存中的， 它有个内存空间，这个对象它有自己的地址值，然后会把地址赋值给变量，</p>
<p>我们今天重点研究的不是堆内存而是栈内存，这里我要执行一行代码即(<strong>mt.run</strong>)它这里就是调用这个run方法</p>
<p>它也会压栈执行，但是这么执行，程序就是单线程的程序了。他会先执行完run方法，在执行主方法里的其他代码。</p>
<p>那什么是多线程程序呢</p>
<p>就是我们在这里调用了<strong>mt.start</strong>方法。调用mt.start方法，它就不一样了。<strong>它会开辟一个新的栈空间</strong>。它调用的是mt.start方法，执行run方法</p>
<p>此时对于cpu而言，我可以选择执行哪个栈空间里的代码，即cpu有了选择的权利，可以执行main方法也可以执行run方法。这个就是多线程的内存空间</p>
<h2 id="2-2、多线程的好处"><a href="#2-2、多线程的好处" class="headerlink" title="2.2、多线程的好处"></a>2.2、多线程的好处</h2><p>多个线程之间互不影响（在不同的栈空间中）</p>
<h1 id="第三章、Thread类"><a href="#第三章、Thread类" class="headerlink" title="第三章、Thread类"></a>第三章、Thread类</h1><h2 id="3-1、thread类的常见方法"><a href="#3-1、thread类的常见方法" class="headerlink" title="3.1、thread类的常见方法"></a>3.1、thread类的常见方法</h2><h3 id="3-1-1、获取线程名称"><a href="#3-1-1、获取线程名称" class="headerlink" title="3.1.1、获取线程名称"></a>3.1.1、获取线程名称</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程常见的方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1、获取线程名称： </span></span><br><span class="line"><span class="comment"> * 	1.1、使用Thread类中的方法getName() String getName() 返回该线程的名称</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	1.2、可以先获取当前正在执行的线程，使用线程中的方法getName()获取线程名</span></span><br><span class="line"><span class="comment"> * 	</span></span><br><span class="line"><span class="comment"> * 	static Thread currentThread()返回对当前正在执行的线程对象引用</span></span><br><span class="line"><span class="comment"> *	获取当前的Id       getId()</span></span><br><span class="line"><span class="comment"> * 	获取当前线程的优先级 getPriority()</span></span><br><span class="line"><span class="comment"> * 	获取当前线程的状态 getState()</span></span><br><span class="line"><span class="comment"> * 	判断当前线程是否还处于活动状态 isAlive()</span></span><br><span class="line"><span class="comment"> * 	判断线程是否为守护线程 isDaemon()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个Thread的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreads</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 重写Thread类中的run方法,设置线程任务</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//		获取线程名</span></span><br><span class="line">		String name2 = getName();</span><br><span class="line">		System.out.println(name2);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//获取当前执行线程</span></span><br><span class="line">		Thread currentThread = Thread.currentThread();</span><br><span class="line">		System.out.println(currentThread);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//链式编程</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThreads mt = <span class="keyword">new</span> MyThreads();</span><br><span class="line">		<span class="comment">//调用start方法,开启新线程,执行run方法</span></span><br><span class="line">		mt.run();</span><br><span class="line">		<span class="keyword">new</span> MyThreads().start();	</span><br><span class="line">		<span class="comment">//链式编程</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2、设置线程名称"><a href="#3-1-2、设置线程名称" class="headerlink" title="3.1.2、设置线程名称"></a>3.1.2、设置线程名称</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	设置线程名称:</span></span><br><span class="line"><span class="comment">		1、使用Thread类中方法setName(名字)</span></span><br><span class="line"><span class="comment">			void setName(String name)</span></span><br><span class="line"><span class="comment">		改变线程名称，使之与参数name相同</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		2、创建带参数的构造方法,参数传递线程的名称</span></span><br><span class="line"><span class="comment">			调用父类的带参构造方法，把线程名称传递给父类</span></span><br><span class="line"><span class="comment">			让父类Thread()给子线程起一个名字</span></span><br><span class="line"><span class="comment">			Thread(String name) 分配新的Thread对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread03</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 开启多线程</span></span><br><span class="line">		Mythread1 th1 = <span class="keyword">new</span> Mythread1();</span><br><span class="line">		th1.setName(<span class="string">&quot;线程1&quot;</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//开启多线程</span></span><br><span class="line">		Mythread1 th2 = <span class="keyword">new</span> Mythread1(<span class="string">&quot;线程2&quot;</span>);</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mythread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span>  <span class="title">Mythread1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Mythread1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//把线程名给父类,让父类Thread给子线程起个名字</span></span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 获取线程名</span></span><br><span class="line">		System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3、设置守护线程"><a href="#3-1-3、设置守护线程" class="headerlink" title="3.1.3、设置守护线程"></a>3.1.3、设置守护线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 守护线程: 守护线程也叫做后台线程,正常创建出来的线程又叫做前台线程 或者 主线程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 主线程可以通过setDemeon()设置成后台线程(守护线程)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当一个程序中,所有的主线程都结束后,此时如果程序中还有守护线程在执行任务 则不管守护线程是否执行完任务,整个程序结束。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 当一个程序中，所有的守护线程任务结束，当此时如果程序中还有主线程在执行任务 则整个程序继续执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;主线程在执行任务 &quot;</span> + i);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="comment">//线程睡眠</span></span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;守护线程在执行任务 &quot;</span> + i);</span><br><span class="line">					</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">500</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;	</span><br><span class="line">		<span class="comment">//将线程2设置成守护线程</span></span><br><span class="line">		th2.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-4、线程睡眠"><a href="#3-1-4、线程睡眠" class="headerlink" title="3.1.4、线程睡眠"></a>3.1.4、线程睡眠</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * sleep(int value) 让当前线程陷入沉睡,沉睡时间为指定的时间,单位是毫秒</span></span><br><span class="line"><span class="comment"> * sleep为静态方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread th = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">5</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">					System.out.println(i);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-5、设置线程优先级"><a href="#3-1-5、设置线程优先级" class="headerlink" title="3.1.5、设置线程优先级"></a>3.1.5、设置线程优先级</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程的优先级：</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 我们不能强制干涉cpu将时间片分配给某个线程</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 但是我们可以控制线程的优先级，从而提高该线程获取时间片的概率</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 数据越大，优先级越高。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 优先级：1-10级，数字越大，优先级越高</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 优先级默认等级为5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(<span class="string">&quot;th1&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;th1正在执行&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(<span class="string">&quot;th2&quot;</span>) &#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;th2正在执行&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * setPriority(int value)</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * 设置当前线程的优先级，需要在线程启动之前调用，之后调用就没有意义</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		th1.setPriority(<span class="number">2</span>);</span><br><span class="line">		th2.setPriority(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-6、线程让步"><a href="#3-1-6、线程让步" class="headerlink" title="3.1.6、线程让步"></a>3.1.6、线程让步</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * yield : 线程让步,当前线程让出自己的cpu资源让其他线程优先执行</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 注:  1、让出的时间不确定; </span></span><br><span class="line"><span class="comment"> *      2、在让出cpu资源时,会先检查是否有相同优先级且处于可运行状态的线程,如果有则让出,否则不让</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;老太太排队买票 &quot;</span> + i);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;小朋友在排队买票 &quot;</span> + i);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">							System.out.println(<span class="string">&quot;开始让出cpu&quot;</span>);</span><br><span class="line">							<span class="comment">/**</span></span><br><span class="line"><span class="comment">							 * 让出cpu资源，让出的时间不确定，若要把cpu全让出，可用线程插队</span></span><br><span class="line"><span class="comment">							 */</span></span><br><span class="line">							Thread.yield();</span><br><span class="line"></span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-7、线程插队"><a href="#3-1-7、线程插队" class="headerlink" title="3.1.7、线程插队"></a>3.1.7、线程插队</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jion() 该方法表示线程插队,当当前线程插队时,其他线程陷入阻塞状态,直到当前线程插队将任务执行完毕</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;老太太排队买票 &quot;</span> + i);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;小朋友在排队买票 &quot;</span> + i);</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">						<span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">							System.out.println(<span class="string">&quot;老太太又事情，先插个队&quot;</span>);</span><br><span class="line">							<span class="comment">/**</span></span><br><span class="line"><span class="comment">							 * 让th1线程插队</span></span><br><span class="line"><span class="comment">							 */</span></span><br><span class="line">							th1.join();</span><br><span class="line">						&#125;</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第四章、实现多线程的第二种方法"><a href="#第四章、实现多线程的第二种方法" class="headerlink" title="第四章、实现多线程的第二种方法"></a>第四章、实现多线程的第二种方法</h1><h2 id="4-1、实现Runnable接口"><a href="#4-1、实现Runnable接口" class="headerlink" title="4.1、实现Runnable接口"></a>4.1、实现Runnable接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	 在java中使用多线程方式2(推荐)：</span></span><br><span class="line"><span class="comment"> * 		  通过实现Runnable接口， 重写run（） ，在其中定义要执行的任务。</span></span><br><span class="line"><span class="comment"> * 		  然后将该任务子类对象添加到线程中执行。</span></span><br><span class="line"><span class="comment"> * 		   </span></span><br><span class="line"><span class="comment"> * 		  好处在于将线程 和 线程要执行的任务分开，避免的线程和任务的强耦合，</span></span><br><span class="line"><span class="comment"> * 		  当前这个线程在完成某个任务以后，可以再去执行别的任务。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	构造方法：</span></span><br><span class="line"><span class="comment"> * 		Thread(Runnable target)分配新的Thread对象</span></span><br><span class="line"><span class="comment"> * 		Thread(Runnable target,String name)分配新的name对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	实现步骤:</span></span><br><span class="line"><span class="comment"> * 		1、创建一个Runnable接口的实现类</span></span><br><span class="line"><span class="comment"> * 		2、在实现类中重写Runnable接口中的run方法</span></span><br><span class="line"><span class="comment"> * 		3、创建一个Runnable接口实现类对象</span></span><br><span class="line"><span class="comment"> * 		4、创建Thread类对象，构造方法中传递Runnable接口的实现类对象</span></span><br><span class="line"><span class="comment"> * 		5、调用Thread类中的start方法开启新的线程,执行run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread06</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//Runnable 可以看作任务类接口</span></span><br><span class="line">		Runnable1 run1 = <span class="keyword">new</span> Runnable1();</span><br><span class="line">		Runnable2 run2 = <span class="keyword">new</span> Runnable2();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将任务对象 添加线程中执行</span></span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(run1);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(run2);</span><br><span class="line">		</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;runnable1接口实现多线程&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;runnable2接口实现多线程&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第五章、Thread和Runnable接口的区别"><a href="#第五章、Thread和Runnable接口的区别" class="headerlink" title="第五章、Thread和Runnable接口的区别"></a>第五章、Thread和Runnable接口的区别</h1><p>如果一个类继承Thread，则不适合资源共享，但是如果实现了Runnable接口的话，则很容易的实现资源共享。</p>
<p><strong>总结：</strong></p>
<p><strong>实现Runnable接口比继承Thread类所具有的优势：</strong></p>
<ol>
<li><p>适合多个相同的程序代码的线程去共享一个资源 </p>
</li>
<li><p>可以避免Java中的单继承的局限性</p>
</li>
<li><p>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立</p>
</li>
<li><p>线程池只能放入实现Runnable或者Callable类线程。不能直接放入继承Thread的类</p>
</li>
</ol>
<p><font color="red">扩充：在Java中，每次程序运行至少启动两个线程，一个是main线程，一个是垃圾收集线程，因为每当使用Java命令执行一个类的时候，实际上都会启动一个JVM，每个JVM其实在就是在操作系统中启动了一个进程</font></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">	实现Runnable接口创建多线程程序的好处</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">	1、避免了单继承的局限性</span></span><br><span class="line"><span class="comment">		一个类只能继承一个类(一个人只能有一个亲爹)</span></span><br><span class="line"><span class="comment">		类继承了Thread类就不能继承其它类</span></span><br><span class="line"><span class="comment">		实现了Runnable接口，还可以继承其它类，实现其它接口</span></span><br><span class="line"><span class="comment">	2、增强程序的扩展性,降低了程序的耦合性(解耦)</span></span><br><span class="line"><span class="comment">		实现Runnable接口的方式,把设置线程任务和开启新线程进行分离(解耦)</span></span><br><span class="line"><span class="comment">		实现类中,重写了run方法,用来设置线程任务</span></span><br><span class="line"><span class="comment">		创建Thread类对象,调用start方法,用来开启新线程</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread08</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable3 run3 = <span class="keyword">new</span> Runnable3();</span><br><span class="line">		Runnable4 run4 = <span class="keyword">new</span> Runnable4();</span><br><span class="line">		</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(run3);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(run4);</span><br><span class="line">		</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable3</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Hello,Runnable&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;HelloWorld&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第六章、匿名内部类的方式实现多线程"><a href="#第六章、匿名内部类的方式实现多线程" class="headerlink" title="第六章、匿名内部类的方式实现多线程"></a>第六章、匿名内部类的方式实现多线程</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	匿名内部类方式</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	匿名:没有名字 内部类:写在其他类内部的类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	匿名内部类的作用:简化代码 把子类继承父类，重写父类的方法创建子类对象可以一步完成 </span></span><br><span class="line"><span class="comment"> * 	把实现实现类接口，重写接口中的方法，创建实现类对象一步完成</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	匿名内部类的最终产物:子类/实现类对象，而这个类它没有名字</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	格式: </span></span><br><span class="line"><span class="comment"> * 	new 父类/接口()&#123;</span></span><br><span class="line"><span class="comment"> * 		 重写父类/接口中的方法</span></span><br><span class="line"><span class="comment"> * 	 &#125;;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread09</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 线程的父类是Thread</span></span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot; &quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"><span class="comment">//		thread.start();</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 实现线程接口Runnable</span></span><br><span class="line">		Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;Runnable&quot;</span> + (i + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(r) &#123;</span><br><span class="line">		&#125;;</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第七章、线程安全问题"><a href="#第七章、线程安全问题" class="headerlink" title="第七章、线程安全问题"></a>第七章、线程安全问题</h1><p>如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 </p>
<p>我们通过一个案例，演示线程的安全问题： </p>
<p>电影院要卖票，我们模拟电影院的卖票过程。假设要播放的电影是 “葫芦娃大战奥特曼”，本次电影的座位共100个 (本场电影只能卖100张票)。 </p>
<p>我们来模拟电影院的售票窗口，实现多个窗口同时卖 “葫芦娃大战奥特曼”这场电影票(多个窗口一起卖这100张票) 需要窗口，采用线程对象来模拟；需要票，Runnable接口子类来模拟</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	线程安全问题:</span></span><br><span class="line"><span class="comment"> 		</span></span><br><span class="line"><span class="comment"> 	案例:此时有个电影院开始售票,它一共贩卖100张</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> 	现在只能让它现场买票，这个就相当于单线程程序(不会出现线程安全问题）</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> 	那此时，一个窗口卖票速度太慢了,变成了三个窗口</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> 	1号窗口贩卖(1-33) 2号窗口贩卖(34-67) 3号窗口贩卖(68-100)</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> 	三个窗口一起卖票，但是卖的票不同，也不会出问题(多线程程序没有访问共享数据)</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> 	现在假如有这么一个情景，还是开设了三个窗口，但是每个窗口都是从1号票开始卖</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> 	这就会出现问题了，是不是就会出现混乱的情况了啊！是不是就会出现不存在的票啊！</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> 	多线程访问了共享的数据会产生安全问题，这个问题是可以解决的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	线程并发带来的安全问题 : 当多个线程操作同一个资源的时候就会引发安全问题</span></span><br><span class="line"><span class="comment"> *	 当多个线程访问同一份临界资源时,由于cpu切换线程的不确定性,会引发多个线程抢资源的现象,导致逻辑上的伦乱,引发数据安全问题。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Java中一般引发安全问题的前提:  </span></span><br><span class="line"><span class="comment"> *		1、多个线程同时访问同一个对象	  </span></span><br><span class="line"><span class="comment"> *		2、操作同一个全局变量</span></span><br><span class="line"><span class="comment"> * 	解决办法 : 通过添加synchronized锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//模拟卖票案例</span></span><br><span class="line">		Runnable1 run1 = <span class="keyword">new</span> Runnable1();</span><br><span class="line">		</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(run1);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(run1);</span><br><span class="line">		Thread th3 = <span class="keyword">new</span> Thread(run1);</span><br><span class="line">	</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">		th3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="comment">//	定义一个多线程共享的票源</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置线程任务，卖票</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用死循环让卖票重复执行</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">// 先判断票是否存在</span></span><br><span class="line">			<span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;还有余票&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;正在售卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">				ticket = ticket - <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发现程序出现了两个问题： </p>
<ol>
<li><p>相同的票数,比如5这张票被卖了两回。 </p>
</li>
<li><p>不存在的票，比如0票与-1票，是不存在的。 </p>
</li>
</ol>
<p>这种问题，几个窗口(线程)票数不同步了，这种问题称为线程不安全。 </p>
<p>线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写 </p>
<p>操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步， </p>
<p>否则的话就可能影响线程安全。 </p>
<h2 id="7-1-线程同步"><a href="#7-1-线程同步" class="headerlink" title="7.1  线程同步"></a>7.1  线程同步</h2><p>当我们使用多个线程访问同一资源的时候，且多个线程中对资源有写的操作，就容易出现线程安全问题。 </p>
<p>要解决上述多线程并发访问一个资源的安全性问题:也就是解决重复票与不存在票问题，Java中提供了同步机制 (<strong>synchronized</strong>)来解决。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">窗口1线程进入操作的时候，窗口2和窗口3线程只能在外等着，窗口1操作结束，窗口1和窗口2和窗口3才有机会进入代码去执行。</span><br><span class="line">也就是说在某个线程修改共享资源的时候，其他线程不能修改该资源，等待修改完毕同步之后，才能去抢夺CPU资源，</span><br><span class="line">完成对应的操作，保证了数据的同步性，解决了线程不安全的现象</span><br></pre></td></tr></table></figure>

<p>为了保证每个线程都能正常执行原子操作,Java引入了线程同步机制。 </p>
<p>那么怎么去使用呢？有三种方式完成同步操作： </p>
<ol>
<li><p>同步代码块。 </p>
</li>
<li><p>同步方法。 </p>
</li>
<li><p>锁机制。 </p>
</li>
</ol>
<h2 id="7-2、同步代码块"><a href="#7-2、同步代码块" class="headerlink" title="7.2、同步代码块"></a>7.2、同步代码块</h2><ul>
<li><strong>同步代码块</strong>： synchronized 关键字可以用于方法中的某个区块中，表示只对这个区块的资源实行互斥访问。 </li>
</ul>
<p>格式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步锁)&#123;</span><br><span class="line">    需要同步操作的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同步锁</strong>: </p>
<p>对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁. </p>
<ol>
<li><p>锁对象 可以是任意类型。 </p>
</li>
<li><p>多个线程对象 要使用同一把锁。 </p>
</li>
</ol>
<p>注意:在任何时候,最多允许一个线程拥有同步锁,谁拿到锁就进入代码块,其他的线程只能在外等着 </p>
<p>(BLOCKED)。 </p>
<p>使用同步代码块解决代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	注意：</span></span><br><span class="line"><span class="comment"> * 		线程安全问题不能产生,我们可以让一个线程在访问共享数据</span></span><br><span class="line"><span class="comment"> * 		的时候，无论是否丢失了cpu的执行权，让其他的线程只能等待</span></span><br><span class="line"><span class="comment"> * 		等待当前线程卖完票，其它线程才能进行卖票。</span></span><br><span class="line"><span class="comment"> * 	</span></span><br><span class="line"><span class="comment"> * 	保证:始终只有一个线程在卖票</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	同步代码块：</span></span><br><span class="line"><span class="comment"> * 	synchronized(同步锁)&#123;</span></span><br><span class="line"><span class="comment"> *   	可能会出现线程安全的代码</span></span><br><span class="line"><span class="comment"> *	&#125;</span></span><br><span class="line"><span class="comment"> *	</span></span><br><span class="line"><span class="comment"> *	注意：</span></span><br><span class="line"><span class="comment"> *		1、同步代码块的锁对象，可以是任意对象</span></span><br><span class="line"><span class="comment"> *		2、但是必须保证多个线程使用的锁对象是同一个</span></span><br><span class="line"><span class="comment"> *		3、锁对象作用:</span></span><br><span class="line"><span class="comment"> *			把同步代码块锁住,只能一个线程在同步代码块中执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable2 run1 = <span class="keyword">new</span> Runnable2();</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		Thread th1 =<span class="keyword">new</span> Thread(run1);</span><br><span class="line">		Thread th2 =<span class="keyword">new</span> Thread(run1);</span><br><span class="line">		Thread th3 =<span class="keyword">new</span> Thread(run1);</span><br><span class="line">		</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">		th3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//	创建一个锁对象</span></span><br><span class="line">	Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//			创建同步代码块</span></span><br><span class="line">			<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">				<span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 票存在，卖票ticket</span></span><br><span class="line">					System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在出售第 &quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line"></span><br><span class="line">					ticket--;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-3、同步基数原理"><a href="#7-3、同步基数原理" class="headerlink" title="7.3、同步基数原理"></a>7.3、同步基数原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	同步技术原理:</span></span><br><span class="line"><span class="comment"> * 		使用了一个锁对象，这个锁对象叫做同步锁，也叫对象锁</span></span><br><span class="line"><span class="comment"> * 		也叫对象监视器，</span></span><br><span class="line"><span class="comment"> * 	</span></span><br><span class="line"><span class="comment"> * 	流程:</span></span><br><span class="line"><span class="comment"> * 		两个线程一起抢夺cpu执行权，谁抢到了谁执行run方法进行卖票</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		t0抢到了cpu的资源执行run方法，遇到synchronized同步代码块</span></span><br><span class="line"><span class="comment"> * 		此时t0检查同步代码块是否有锁对象,发现有，就会获取到锁对象，进入到同步中执行	</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 		t1抢到了cpu的执行权，执行run方法，遇到synchronized同步代码块</span></span><br><span class="line"><span class="comment"> *		此时t1检查同步代码块是否有锁对象,发现有，就会获取到锁对象，进入到同步中执行	</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		t1发现没有锁对象，就会进入到阻塞状态，会一直等待。t0线程归还锁对象</span></span><br><span class="line"><span class="comment"> *		一直到t0线程执行完同步中的代码，就会把锁对象归还给同步代码块</span></span><br><span class="line"><span class="comment"> *		t1才能获取到锁对象，进入到同步中执行</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	总结:</span></span><br><span class="line"><span class="comment"> *		同步中的线程,没有执行完，不会释放锁，同步外的线程没有锁进不去</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	注意：</span></span><br><span class="line"><span class="comment"> *		同步保证了只能有一个线程在同步中执行共享数据，保证了安全</span></span><br><span class="line"><span class="comment"> *		程序频繁的判断锁，获取锁，释放锁，程序的效率会变低</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable3 run3 = <span class="keyword">new</span> Runnable3();</span><br><span class="line">		</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(run3) ;</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(run3);</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> money;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name, <span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeMoney</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.money -= money;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() </span><br><span class="line">					+ <span class="string">&quot;取款后剩余&quot;</span> + <span class="keyword">this</span>.money);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable3</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	Account account = <span class="keyword">new</span> Account(<span class="string">&quot;llw&quot;</span>, <span class="number">10000</span>);</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		account.takeMoney(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-4、同步方法"><a href="#7-4、同步方法" class="headerlink" title="7.4、同步方法"></a>7.4、同步方法</h2><ul>
<li><strong>同步方法</strong>:使用synchronized修饰的方法,就叫做同步方法,保证A线程执行该方法的时候,其他线程只能在方法外等着。 </li>
</ul>
<p>格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    可能会产生线程安全问题的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同步锁是谁? </p>
<p>对于非static方法,同步锁就是this。 </p>
<p>对于static方法,我们使用当前方法所在类的字节码对象(类名.class)。 </p>
<p>使用同步方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	在方法上加个synchronized关键字</span></span><br><span class="line"><span class="comment"> 		</span></span><br><span class="line"><span class="comment"> 	案例:</span></span><br><span class="line"><span class="comment"> 		卖票案例出现线程安全问题</span></span><br><span class="line"><span class="comment"> 		卖出了重复的票和不存在的票</span></span><br><span class="line"><span class="comment"> 		</span></span><br><span class="line"><span class="comment"> 		解决线程问题的方案:使用同步方法来解决</span></span><br><span class="line"><span class="comment"> 		</span></span><br><span class="line"><span class="comment"> 	使用步骤</span></span><br><span class="line"><span class="comment"> 	1、把访问共享数据的代码抽取出来，方法方法中</span></span><br><span class="line"><span class="comment"> 	2、在方法上添加修饰符synchronized</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> 	格式:</span></span><br><span class="line"><span class="comment"> 		定义方法的格式</span></span><br><span class="line"><span class="comment"> 	</span></span><br><span class="line"><span class="comment"> 	修饰符 synchronized 返回值类型 方法名(参数列表)&#123;</span></span><br><span class="line"><span class="comment"> 		可能会出现线程安全问题的代码</span></span><br><span class="line"><span class="comment"> 	&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized锁  实际上锁的不是某段代码，某个方法，而是锁的是此方法，或者同步块所指定的对象</span></span><br><span class="line"><span class="comment"> *	 当某个线程去访问这些加了synchronized锁的代码时，对应的对象就被上锁。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 	同步锁的互斥：当我们使用线程访问了某个对象中的带synchronized的方法（代码段）</span></span><br><span class="line"><span class="comment"> * 	那么该对象中的其他synchronized方法（代码段）</span></span><br><span class="line"><span class="comment"> * 	也都不可以被其他线程同时访问，但是非synchronized方法不受限制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnable4 run4 = <span class="keyword">new</span> Runnable4();</span><br><span class="line">		</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(run4);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(run4);</span><br><span class="line">		Thread th3 = <span class="keyword">new</span> Thread(run4);</span><br><span class="line">		</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">		th3.start();</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnable4</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//卖票</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			payTicket();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 	定义一个同步方法</span></span><br><span class="line"><span class="comment">	 	同步方法也会把方法内部的代码锁住</span></span><br><span class="line"><span class="comment">	 	只让一个线程执行 </span></span><br><span class="line"><span class="comment">	 	同步方法锁的对象是谁?</span></span><br><span class="line"><span class="comment">	 	就是实现类对象，即new Runnable4() 也就是this</span></span><br><span class="line"><span class="comment">	 	即谁调用这个方法，对象就是谁</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">payTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//票存在ticket--</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">					+<span class="string">&quot;正在贩卖&quot;</span> + ticket +<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">			ticket--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-5、静态锁"><a href="#7-5、静态锁" class="headerlink" title="7.5、静态锁"></a>7.5、静态锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	 静态锁： 在静态方法上加锁， 此时锁的不是方法所在的对象（因为静态方法不是某个对象的，而是被该类的全体对象所共有的），</span></span><br><span class="line"><span class="comment"> *   此时实际上锁的是当前类对应的Class(存放类信息的类,jvm加载的每一个类，都有一个对应的Class实例)对象。</span></span><br><span class="line"><span class="comment"> *   所以此时，调用上锁的静态方法时，是否同步执行，和是哪个对象无关。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	 注意：静态的同步方法，锁对象是谁？ 不是this，this是创建对象之后产生的</span></span><br><span class="line"><span class="comment"> *		  静态方法优先于对象</span></span><br><span class="line"><span class="comment"> *		  静态方法的锁对象是本来的class属性 --&gt; class文件对象(反射)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Runnalbe5 run5 = <span class="keyword">new</span> Runnalbe5();</span><br><span class="line">		</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(run5);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(run5);</span><br><span class="line">		Thread th3 = <span class="keyword">new</span> Thread(run5);</span><br><span class="line">		</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">		th3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Runnalbe5</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            payStaticTicket();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">payStaticTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * 这样也可以保证锁对象是唯一的</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * synchronized (Runnalbe5.class) &#123;</span></span><br><span class="line"><span class="comment">		 * </span></span><br><span class="line"><span class="comment">		 * &#125;</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;	</span><br><span class="line">			<span class="comment">//票存在ticket--</span></span><br><span class="line">			System.out.println(Thread.currentThread().getName()</span><br><span class="line">					+<span class="string">&quot;正在贩卖&quot;</span> + ticket +<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">			ticket--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-6、线程脏读问题"><a href="#7-6、线程脏读问题" class="headerlink" title="7.6、线程脏读问题"></a>7.6、线程脏读问题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	线程脏读问题:</span></span><br><span class="line"><span class="comment"> * 	此时可能就会出现脏读：即一个线程进行写数据操作的时候，执行到一半时间片耗尽，</span></span><br><span class="line"><span class="comment"> * 	此时有另一个线程去执行读数据的操作，但是读操作是没有加锁的可以被并发访问</span></span><br><span class="line"><span class="comment"> * 	此时可能读到的是另一个线程处理了一般的数据，此时可能读到的是另一个线程处理了一半的数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Accounts accounts = <span class="keyword">new</span> Accounts(<span class="string">&quot;llw&quot;</span>,<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(<span class="string">&quot;th1&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				accounts.setMoney(<span class="number">500</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;th1 :&quot;</span> + accounts.getMoney());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(<span class="string">&quot;th2&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;th2 :&quot;</span> + accounts.getMoney());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Accounts</span></span>&#123;</span><br><span class="line">	String userName;</span><br><span class="line">	<span class="keyword">double</span> money;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Accounts</span><span class="params">(String userName,<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.userName = userName;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="comment">/*synchronized*/</span><span class="function"><span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(<span class="keyword">double</span> money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">500</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.money -= money;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span><span class="comment">/*synchronized*/</span> <span class="function"><span class="keyword">double</span> <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> money;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-7、内存的可见性问题-和-volatile关键字"><a href="#7-7、内存的可见性问题-和-volatile关键字" class="headerlink" title="7.7、内存的可见性问题 和 volatile关键字"></a>7.7、内存的可见性问题 和 volatile关键字</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  内存的可见性问题 和 volatile关键字</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  在下述案例中我们期望通过线程2修改status变量的值，去停止线程1 但是实际上并没有成功</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  	为什么发生这样的结果：和jvm的内存模型相关，在jvm中全局共享变量存放在主存中（堆中） 而每个线程都有属于自己的私有的本地内存，当程序运行起来以后，</span></span><br><span class="line"><span class="comment">  	CPU为了避免频繁的去主存中读取数据，而导致性能降低，所以会先将主存中的数据复制一份到线程的本地内存中，</span></span><br><span class="line"><span class="comment">  	然后所有对数据的操作都是对本地内存中的副本进行操作，操作完毕后，会在合适的时机将数据刷新到主存中去 此时如果多个线程去访问同一份数据都是先拷贝一份到本地中</span></span><br><span class="line"><span class="comment"> 	而某个线程刷新了主存中的数据以后，其他的线程并不一定能感知到主存中的数据已经发生了改变 此时就导致了线程之间的可见性问题。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  	解决的办法：</span></span><br><span class="line"><span class="comment">  		1、对数据操作时使用线程锁 synchronized 或者 Lock </span></span><br><span class="line"><span class="comment">  		2、在对操作的变量前加volatile关键字</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  volatile关键字： 是Java提供的一种轻量级的同步机制（并不能解决线程安全问题！！！！）</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  	当一个变量被volatile关键字修饰以后，某个线程对此数据修改，刷新到主存中后，jvm会通知其他线程次数据已经发生改变</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 	此时数据已经发生了变化，其他线程就会重新载入这个数据</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">  线程的可见性：指的是某条线程修改了多个线程的共享的全局变量数据，新的值对其他线程来说也是可以立刻得知的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07</span> </span>&#123;</span><br><span class="line"><span class="comment">//	boolean status = true;</span></span><br><span class="line">	<span class="keyword">volatile</span> <span class="keyword">boolean</span> status = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Demo07 d7 = <span class="keyword">new</span> Demo07();</span><br><span class="line"></span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(<span class="string">&quot;th1&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">				String thName = Thread.currentThread().getName();</span><br><span class="line">				System.out.println(thName + <span class="string">&quot;开始执行..&quot;</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">while</span> (d7.status) &#123;</span><br><span class="line"></span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(thName + <span class="string">&quot;执行完毕&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(<span class="string">&quot;th2&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				String thName = Thread.currentThread().getName();</span><br><span class="line">				System.out.println(thName + <span class="string">&quot;开始执行&quot;</span>);</span><br><span class="line">				d7.status = <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		th1.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		th2.start();</span><br><span class="line">		System.out.println(d7.status);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * volatile 不能替代synchronized锁机制，它还是会引发线程安全问题</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span>	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 1、测试volatile会引发安全问题</span></span><br><span class="line"><span class="comment">//		Thread th1 = new Thread() &#123;</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public void run() &#123;</span></span><br><span class="line"><span class="comment">//				for (int i = 0; i &lt; 10000; i++) &#123;</span></span><br><span class="line"><span class="comment">//					numadd();</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;;</span></span><br><span class="line"><span class="comment">//		Thread th2 = new Thread() &#123;</span></span><br><span class="line"><span class="comment">//			@Override</span></span><br><span class="line"><span class="comment">//			public void run() &#123;</span></span><br><span class="line"><span class="comment">//				for (int i = 0; i &lt; 10000; i++) &#123;</span></span><br><span class="line"><span class="comment">//					numadd();</span></span><br><span class="line"><span class="comment">//				&#125;</span></span><br><span class="line"><span class="comment">//			&#125;</span></span><br><span class="line"><span class="comment">//		&#125;;</span></span><br><span class="line"><span class="comment">//		th1.start();</span></span><br><span class="line"><span class="comment">//		th2.start();</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		try &#123;</span></span><br><span class="line"><span class="comment">//			Thread.sleep(1000);</span></span><br><span class="line"><span class="comment">//		&#125; catch (InterruptedException e) &#123;</span></span><br><span class="line"><span class="comment">//			e.printStackTrace();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		System.out.println(num);</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2、测试 synchronized不会引发安全问题</span></span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(<span class="string">&quot;th1&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">					numadd();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(<span class="string">&quot;th2&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">					numadd();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.println(num);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="comment">//	  public static void numadd() &#123; num++; &#125;</span></span><br><span class="line">	 </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">numadd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		num++;</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-8、synchronized锁的重入机制"><a href="#7-8、synchronized锁的重入机制" class="headerlink" title="7.8、synchronized锁的重入机制"></a>7.8、synchronized锁的重入机制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * synchronized锁的重入（重新进入）机制：</span></span><br><span class="line"><span class="comment"> * 当一个线程获得一个对象的锁以后，在该锁中执行代码的时候，可以再次获得该对象的锁。</span></span><br><span class="line"><span class="comment"> * 例子：比如下面的method1()方法被线程访问了以后，对应的对象被锁定了，其他的带synchronized的方法也不可以被访问，</span></span><br><span class="line"><span class="comment"> * 但是在method1()里面又调用了method2()方法。按理说此时程序是不可以继续向下执行的，变成死锁</span></span><br><span class="line"><span class="comment"> * 但是实际上它是可以继续执行的，因为锁的重入机制，虽然调用method1()的时候，获取了对应的对象的锁，此时在这个锁的内部执行代码</span></span><br><span class="line"><span class="comment"> * 可以再次获取同一个对象的锁，即继续执行method2()方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		method2();</span><br><span class="line">		System.out.println(<span class="string">&quot;method1()....&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;method2()...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Demo01 demo01 = <span class="keyword">new</span> Demo01();</span><br><span class="line">		Thread th = <span class="keyword">new</span> Thread(<span class="string">&quot;th1&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				demo01.method1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-9、死锁"><a href="#7-9、死锁" class="headerlink" title="7.9、死锁"></a>7.9、死锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 死锁： 多个线程在竞争资源的时候，过多的同步方法导致线程推进不当， 两个或者以上线程持有对方所需要的锁，但是又不可以及时释放，</span></span><br><span class="line"><span class="comment"> * 导致线程之间都在等待对方释放锁，最终引发死锁问题。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 例子： 有线程th1和th2，以及有两个被锁对象obj1和obj2 线程1执行的时候，需要先锁obj1在去锁obj2</span></span><br><span class="line"><span class="comment"> * 与此同时，线程th2也在并发执行，需要先锁obj2，在去锁obj1</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 此时，可能就会出现线程th1拿到obj1锁的时候，发现obj2锁已经被th2拿了</span></span><br><span class="line"><span class="comment"> * 那么此时th1就只能等待th2释放锁，但是th2释放obj2的锁，需要先拿到obj1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">	Object obj1 = <span class="keyword">new</span> Object();</span><br><span class="line">	Object obj2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;锁完boj1以后，去锁obj2&quot;</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">500</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 想要2</span></span><br><span class="line">			<span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;锁定obj2&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (obj2) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;锁完boj2以后，去锁obj1&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">500</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 想要1</span></span><br><span class="line">			<span class="keyword">synchronized</span> (obj1) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;锁定obj1&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Demo02 demo02 = <span class="keyword">new</span> Demo02();</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(<span class="string">&quot;th1&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				demo02.method2();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(<span class="string">&quot;th2&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				demo02.method1();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-10、Lock锁"><a href="#7-10、Lock锁" class="headerlink" title="7.10、Lock锁"></a>7.10、Lock锁</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lock锁： Lock实现了比synchronized锁更广泛的锁操作</span></span><br><span class="line"><span class="comment"> * 接口中提供了两个方法</span></span><br><span class="line"><span class="comment"> * 1、Lock：获取锁</span></span><br><span class="line"><span class="comment"> * 2、unlock:释放锁</span></span><br><span class="line"><span class="comment"> * 他能够知道什么时候获取锁，什么时候释放锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * java.util.conurrent.locks.ReentrantLock implement Lock</span></span><br><span class="line"><span class="comment"> * 使用步骤（既然是接口，就要实现它的实现类）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1、在成员位置上创建一个ReentrantLock对象</span></span><br><span class="line"><span class="comment"> * 2、可能会出现安全问题的代码前，调用Lock方法获取锁</span></span><br><span class="line"><span class="comment"> * 3、可能会出现安全问题的代码后，调用unLock释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Rannable10 run10 = <span class="keyword">new</span> Rannable10();</span><br><span class="line">		</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(run10);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(run10);</span><br><span class="line">		Thread th3 = <span class="keyword">new</span> Thread(run10);</span><br><span class="line">		</span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">		th3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rannable10</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//	1、在成员变量前创建Lock锁</span></span><br><span class="line">	Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//		2、可能会出现安全问题的代码前，调用Lock方法获取锁</span></span><br><span class="line">			lock.lock();</span><br><span class="line">			payticket();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payticket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket +<span class="string">&quot;张票&quot;</span>);</span><br><span class="line">			ticket--;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="comment">//		3、可能会出现安全问题的代码后，调用unLock释放锁</span></span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实它还有一种更好的写法，那我们来一起看一下怎个要怎么写吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lock锁： Lock实现了比synchronized锁更广泛的锁操作 </span></span><br><span class="line"><span class="comment"> * 接口中提供了两个方法 </span></span><br><span class="line"><span class="comment"> * 		1、Lock：获取锁 </span></span><br><span class="line"><span class="comment"> *		2、unlock:释放锁</span></span><br><span class="line"><span class="comment"> * 他能够知道什么时候获取锁，什么时候释放锁</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * java.util.conurrent.locks.ReentrantLock implement Lock 使用步骤（既然是接口，就要实现它的实现类）</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1、在成员位置上创建一个ReentrantLock对象 </span></span><br><span class="line"><span class="comment"> * 2、可能会出现安全问题的代码前，调用Lock方法获取锁</span></span><br><span class="line"><span class="comment"> * 3、可能会出现安全问题的代码后，调用unLock释放锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lock(java提供的lock对象来实现synchronized相同的效果);</span></span><br><span class="line"><span class="comment"> * Lock是一个接口类型，常见的子实现类为Reentrantlock</span></span><br><span class="line"><span class="comment"> * 使用的时候先创建lock对象，通过lock方法加锁，unlock()方法手动释放锁</span></span><br><span class="line"><span class="comment"> * 在他们之间的代码就都被上锁了，变成同步执行的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		Rannable10 run10 = <span class="keyword">new</span> Rannable10();</span><br><span class="line"></span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(run10);</span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread(run10);</span><br><span class="line">		Thread th3 = <span class="keyword">new</span> Thread(run10);</span><br><span class="line"></span><br><span class="line">		th1.start();</span><br><span class="line">		th2.start();</span><br><span class="line">		th3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rannable10</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//	1、在成员变量前创建Lock锁</span></span><br><span class="line">	Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//		2、可能会出现安全问题的代码前，调用Lock方法获取锁</span></span><br><span class="line">			lock.lock();</span><br><span class="line">			payticket();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">payticket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (ticket &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在卖第&quot;</span> + ticket + <span class="string">&quot;张票&quot;</span>);</span><br><span class="line">				ticket--;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">                <span class="comment">// 加了finally</span></span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//				3、可能会出现安全问题的代码后，调用unLock释放锁</span></span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第八章、线程状态"><a href="#第八章、线程状态" class="headerlink" title="第八章、线程状态"></a>第八章、线程状态</h1><h2 id="8-1、线程状态概述"><a href="#8-1、线程状态概述" class="headerlink" title="8.1、线程状态概述"></a>8.1、线程状态概述</h2><p>当线程被创建并启动以后，它既不是已启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，有几种状态呢？</p>
<table>
<thead>
<tr>
<th>线程状态</th>
<th>导致状态发生条件</th>
</tr>
</thead>
<tbody><tr>
<td>new（新建）</td>
<td>线程刚被创建，但是未启动，还没调用start方法</td>
</tr>
<tr>
<td>runnable（可运行）</td>
<td>线程可以在java虚拟机中运行的状态，可能正在运行自己的代码，也可能没有，这取决于操作系统的处理器</td>
</tr>
<tr>
<td>Blocked（锁阻塞）</td>
<td>当一个线程试图获取一个对象锁，而该对象锁被其他线程持有，则该线程进入Blocked状态，当该线程持有锁，改线程编程Runnable状态</td>
</tr>
<tr>
<td>waiting（无限等待）</td>
<td>一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入waiting状态，进入这个状态后时不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能唤醒</td>
</tr>
<tr>
<td>Timed Waiting（计时等待、休眠）</td>
<td>同waiting状态，有几个方法会有超时参数，调用他们进入Timed Waiting状态，这一状态将一直保持到超时期满或者接收到唤醒通知，带有超时参数的常用方法有Thread.sleep、Object wait</td>
</tr>
<tr>
<td>Teminated（死亡状态）</td>
<td>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td>
</tr>
</tbody></table>
<p><strong>注意：他们各个状态之间可以相互转换</strong></p>
<p><img src="https://img-blog.csdnimg.cn/cd47c24357a242fa855ad44ff0dbf7a6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0plZ3JldA==,size_16,color_FFFFFF,t_70"></p>
<h2 id="8-2-Timed-Waiting（计时等待）"><a href="#8-2-Timed-Waiting（计时等待）" class="headerlink" title="8.2 Timed Waiting（计时等待）"></a>8.2 Timed Waiting（计时等待）</h2><p>Timed Waiting在API中的描述为：一个正在限时等待另一个线程执行一个（唤醒）动作的线程处于这一状态。单独的去理解这句话，真是玄之又玄，其实我们在之前的操作中已经接触过这个状态了，在哪里呢？ </p>
<p>在我们写卖票的案例中，为了减少线程执行太快，现象不明显等问题，我们在run方法中添加了sleep语句，这样就强制当前正在执行的线程休眠（<strong>暂停执行</strong>），以“减慢线程”。 </p>
<p>其实当我们调用了sleep方法之后，当前执行的线程就进入到“休眠状态”，其实就是所谓的Timed Waiting(计时等 </p>
<p>待)，那么我们通过一个案例加深对该状态的一个理解。 </p>
<p><strong>实现一个计数器，计数到100</strong>，在每个数字之间暂停<strong>1</strong>秒，每隔<strong>10</strong>个数字输出一个字符串 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *	实现一个计数器，计数到100，在每个数字之间暂停1秒，</span></span><br><span class="line"><span class="comment"> *	每隔10个数字输出一个字符串	</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 	在这我们新建一个线程，它是处于可以运行状态</span></span><br><span class="line"><span class="comment"> * 	如果我们调用了sleep方法，它就会进入到计时等待状态</span></span><br><span class="line"><span class="comment"> * 	等待结束以后，它又会回到可运行的状态</span></span><br><span class="line"><span class="comment"> * 	这个就被叫做计时等待</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">					<span class="keyword">if</span> (i % <span class="number">10</span> == <span class="number">0</span>) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;每间隔10个数字输出一个字符串&quot;</span> + i);</span><br><span class="line">						System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					System.out.println(<span class="string">&quot;i = &quot;</span> + i);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过案例可以发现，sleep方法的使用还是很简单的。我们需要记住下面几点： </p>
<ol>
<li><p>进入 TIMED_WAITING 状态的一种常见情形是调用的 sleep 方法，单独的线程也可以调用，不一定非要有协作关系。</p>
</li>
<li><p>为了让其他线程有机会执行，可以将Thread.sleep()的调用<strong>放线程run()之内</strong>。这样才能保证该线程执行过程中会睡眠 </p>
</li>
<li><p>sleep与锁无关，线程睡眠到期自动苏醒，并返回到Runnable（可运行）状态。 </p>
</li>
</ol>
<p>小提示：sleep()中指定的时间是线程不会运行的最短时间。因此，sleep()方法不能保证该线程睡眠到期后就 </p>
<p>开始立刻执行。 </p>
<h2 id="8-3-BLOCKED（锁阻塞）"><a href="#8-3-BLOCKED（锁阻塞）" class="headerlink" title="8.3 BLOCKED（锁阻塞）"></a>8.3 BLOCKED（锁阻塞）</h2><p>Blocked状态在API中的介绍为：一个正在阻塞等待一个监视器锁（锁对象）的线程处于这一状态。 </p>
<p>我们已经学完同步机制，那么这个状态是非常好理解的了。比如，线程A与线程B代码中使用同一锁，如果线程A获取到锁，线程A进入到Runnable状态，那么线程B就进入到Blocked锁阻塞状态。 </p>
<p>这是由Runnable状态进入Blocked状态。除此Waiting以及Time Waiting状态也会在某种情况下进入阻塞状态，而这部分内容作为扩充知识点带领大家了解一下。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 锁阻塞:</span></span><br><span class="line"><span class="comment"> * 	首先它也是先创建一个线程，它处于可运行的状态</span></span><br><span class="line"><span class="comment"> * 	什么被称之为可运行的状态呢，就是它可以运行，但是它需要和别的线程去争抢cpu执行权</span></span><br><span class="line"><span class="comment"> * 	没有争取到锁的对象进入到锁阻塞的状态</span></span><br><span class="line"><span class="comment"> * 	如果锁阻塞状态的线程，获取到锁对象，它就会进入到可运行的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-4-Waiting（无限等待）"><a href="#8-4-Waiting（无限等待）" class="headerlink" title="8.4 Waiting（无限等待）"></a>8.4 Waiting（无限等待）</h2><p>Wating状态在API中介绍为：一个正在无限期等待另一个线程执行一个特别的（唤醒）动作的线程处于这一状态。 </p>
<p>那么我们之前遇到过这种状态吗？答案是并没有，但并不妨碍我们进行一个简单深入的了解。我们通过一段代码来 </p>
<p>学习一下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	无限等待：</span></span><br><span class="line"><span class="comment"> *	等待唤醒案例（线程之间的通信）</span></span><br><span class="line"><span class="comment"> *	有两个商铺，一个卖包子的商铺，一个买包子的商铺</span></span><br><span class="line"><span class="comment"> *	顾客要买包子，和老板说明买包子的数量和种类，</span></span><br><span class="line"><span class="comment"> *	顾客就等着老板做包子（调用wait方法）</span></span><br><span class="line"><span class="comment"> *	waiting状态，无限等待</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	老板开始做包子，根据你的需要来做包子，做好包子告诉顾客（调用notify)</span></span><br><span class="line"><span class="comment"> *	告诉顾客包子做好了，就可以开始吃了</span></span><br><span class="line"><span class="comment"> *	所以顾客和老板之间就形成了一个通信</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	顾客来买包子，要等待老板做包子，调用wait方法</span></span><br><span class="line"><span class="comment"> *	老板做好包子，告诉顾客包子做好了，调用notify方法</span></span><br><span class="line"><span class="comment"> *	这个就形成线程之间的通信</span></span><br><span class="line"><span class="comment"> *	</span></span><br><span class="line"><span class="comment"> */</span>	</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	等待唤醒案例：线程之间的通信</span></span><br><span class="line"><span class="comment"> * 		创建一个顾客线程(消费者)告知老板要的包子的种类和数量</span></span><br><span class="line"><span class="comment"> * 		调用wait方法，放弃cpu的执行，进入到WAITING无限等待状态</span></span><br><span class="line"><span class="comment"> * 		</span></span><br><span class="line"><span class="comment"> *		创建一个老板线程(生产者)花了5秒做包子，做好包子之后，调用</span></span><br><span class="line"><span class="comment"> *		notify方法唤醒顾客，吃包子</span></span><br><span class="line"><span class="comment"> *	</span></span><br><span class="line"><span class="comment"> *	注意:顾客和老板线程必须使用同步代码块包裹起来，包子等待和唤醒只能有</span></span><br><span class="line"><span class="comment"> *		一个在执行</span></span><br><span class="line"><span class="comment"> *		同步使用的锁对象必须保证唯一</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *		只有锁对象才能调用wait和notify方法，非锁对象是不能调用的</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	object类中的方法</span></span><br><span class="line"><span class="comment"> *		void wait()</span></span><br><span class="line"><span class="comment"> *			在其他线程调用此对象的notify()方法或者notifyAll()方法前，导致当前线程等待</span></span><br><span class="line"><span class="comment"> *		</span></span><br><span class="line"><span class="comment"> *		void notify()</span></span><br><span class="line"><span class="comment"> *			唤醒在此对象监视器上等待的单个线程</span></span><br><span class="line"><span class="comment"> *			会继续执行wait方法之后的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo05</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建锁对象，保证唯一</span></span><br><span class="line">		Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个顾客线程（消费者)</span></span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="comment">// 保证等待和唤醒的线程只能有一个执行，需要使用同步技术</span></span><br><span class="line">					<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;顾客线程(消费者)告知老板要的包子的种类和数量&quot;</span>);</span><br><span class="line">						<span class="comment">// 调用wait方法，让它进入到无限等待状态</span></span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							obj.wait();</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 唤醒之后执行的代码</span></span><br><span class="line">						System.out.println(<span class="string">&quot;包子已经做好了，可以开始吃了&quot;</span>);</span><br><span class="line">						System.out.println(<span class="string">&quot;------------------------&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th1.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建一个老板线程（生产者)</span></span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//						老板线程(生产者)花了5秒做包子，做好包子之后，</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">5000</span>);<span class="comment">// 花5秒做包子</span></span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="comment">// 保证等待和唤醒的线程只能有一个执行，需要使用同步技术</span></span><br><span class="line">					<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;做好包子，告知顾客，可以吃包子了&quot;</span>);</span><br><span class="line"><span class="comment">//						调用notify方法唤醒顾客，吃包子</span></span><br><span class="line">						obj.notify();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th2.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述案例我们会发现，一个调用了某个对象的 Object.wait 方法的线程会等待另一个线程调用此对象的 </p>
<p>Object.notify()方法 或 Object.notifyAll()方法。 </p>
<p>其实waiting状态并不是一个线程的操作，它体现的是多个线程间的通信，可以理解为多个线程之间的协作关系， </p>
<p>多个线程会争取锁，同时相互之间又存在协作关系。就好比在公司里你和你的同事们，你们可能存在晋升时的竞争，但更多时候你们更多是一起合作以完成某些任务。 </p>
<p>当多个线程协作时，比如A，B线程，如果A线程在Runnable（可运行）状态中调用了wait()方法，那么A线程就进入了Waiting（无限等待）状态，同时失去了同步锁。假如这个时候B线程获取到了同步锁，在运行状态中调用了</p>
<p>notify()方法，那么就会将无限等待的A线程唤醒。注意是唤醒，如果获取到锁对象，那么A线程唤醒后就进入 </p>
<p>Runnable（可运行）状态；如果没有获取锁对象，那么就进入到Blocked（锁阻塞状态）。 </p>
<h2 id="8-5、wait和notify"><a href="#8-5、wait和notify" class="headerlink" title="8.5、wait和notify"></a>8.5、wait和notify</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 	Object类中wait带参方法和notifyAll()方法</span></span><br><span class="line"><span class="comment"> *	 </span></span><br><span class="line"><span class="comment"> *	进入到TimeWaiting(即使等待)有两种方式</span></span><br><span class="line"><span class="comment"> *	1、使用sleep（long m) 方法,在毫秒结束以后，线程睡醒</span></span><br><span class="line"><span class="comment"> *	进入到Runnable/Blocked状态</span></span><br><span class="line"><span class="comment"> *	</span></span><br><span class="line"><span class="comment"> *	2、使用wait(long m)方法，wait方法如果在毫秒结束之后</span></span><br><span class="line"><span class="comment"> *	还没被notify唤醒，就会自动醒来</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *	唤醒的方法:</span></span><br><span class="line"><span class="comment"> *		void notify()</span></span><br><span class="line"><span class="comment"> *			唤醒在此对象监视器上等待的单个线程，</span></span><br><span class="line"><span class="comment"> *		void notifyAll()</span></span><br><span class="line"><span class="comment"> *			唤醒在此对象监视器上等待的所有线程，</span></span><br><span class="line"><span class="comment"> *	</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 创建锁对象，保证唯一</span></span><br><span class="line">		Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">		Thread th1 = <span class="keyword">new</span> Thread(<span class="string">&quot;th1&quot;</span>) &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;顾客1告诉老板要的包子种类和数&quot;</span>);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							obj.wait(<span class="number">5000</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 唤醒之后执行的代码</span></span><br><span class="line">						System.out.println(<span class="string">&quot;顾客1包子已经做好了，开吃&quot;</span>);</span><br><span class="line">						System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th1.start();</span><br><span class="line"></span><br><span class="line">		Thread th2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;顾客2告诉老板要的包子种类和数&quot;</span>);</span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							obj.wait(<span class="number">5000</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="comment">// 唤醒之后执行的代码</span></span><br><span class="line">						System.out.println(<span class="string">&quot;顾客2包子已经做好了，开吃&quot;</span>);</span><br><span class="line">						System.out.println(<span class="string">&quot;-----------------&quot;</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th2.start();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 老板线程</span></span><br><span class="line">		Thread th3 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;老板5秒钟后做好包子&quot;</span></span><br><span class="line">								+<span class="string">&quot;告知顾客，包子可以吃了&quot;</span>);</span><br><span class="line">						obj.notify();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		th3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="第九章、等待与唤醒机制"><a href="#第九章、等待与唤醒机制" class="headerlink" title="第九章、等待与唤醒机制"></a>第九章、等待与唤醒机制</h1><h2 id="9-1、线程之间的通信"><a href="#9-1、线程之间的通信" class="headerlink" title="9.1、线程之间的通信"></a>9.1、线程之间的通信</h2><p><strong>概念：</strong>多线程在处理同一个资源，但是处理的动作(线程任务)却不同。</p>
<p>比如：A线程是用来生产包子的，B线程是用来吃包子的。包子可以理解为同一资源，线程A和线程B处理的动作一个是生产，一个是消费。那么线程A和线程B之间就存在线程通信问题，大家也可以把他们理解成以后工作以后的合作，一个人做登陆，一个人做注册，一个人做购买，等等。所以线程之间也可以存在一个通信，称为合作。</p>
<h2 id="9-2、为什么要处理线程通信"><a href="#9-2、为什么要处理线程通信" class="headerlink" title="9.2、为什么要处理线程通信"></a>9.2、为什么要处理线程通信</h2><p>多线程并发执行时，在默认情况下cpu是随机切换线程的，当我们需要多个线程共同完成一个任务，并且我们希望他们有规律的去执行，那么多线程之间需要一些协调通信，以此来帮我们达到多线程共同操作一份数据。</p>
<h2 id="9-3、如何保证线程间通信有效利用资源"><a href="#9-3、如何保证线程间通信有效利用资源" class="headerlink" title="9.3、如何保证线程间通信有效利用资源"></a>9.3、如何保证线程间通信有效利用资源</h2><p>多个线程在处理同一个资源，并且任务不同时，需要线程通信来帮助解决线程之间对同一个变量的使用或操作，就说多个线程在操作同一个数据时，避免对同一变量的争夺，也就是我们需要通过一定的手段，使各个线程能有效的利用资源，而这种手段被称之为 – <strong>等待唤醒机制</strong>。</p>
<h2 id="9-4、等待唤醒机制"><a href="#9-4、等待唤醒机制" class="headerlink" title="9.4、等待唤醒机制"></a>9.4、等待唤醒机制</h2><p><strong>什么是等待唤醒机制</strong></p>
<p>这个是多个线程之间的一种<strong>协作</strong>机制，讲到线程，我们经常讲到的是线程之间的<strong>竞争</strong>(<strong>race</strong>),比如去争夺锁，但是这并不是故事的全部，线程之间也会有协作机制，就好比在公司里面，你和你的同事，你们之间就存在着晋升时的竞争，但是更多的时候，你们可能存在的时候，你们需要一起合作完成某些事情的一个合作关系。</p>
<p>就是在线程进行了规定的操作以后，就进入到一个等待状态（<strong>wait()</strong> ) ，等待其他线程完成执行完他们指定的代码过后，在将其唤醒（<strong>notify()</strong> )；在有多个线程进入等待以后，如果需要，可以使用 <strong>notifyAll()</strong> 来唤醒所有线程，</p>
<p><strong>wait/notify</strong>就是一种线程协作机制</p>
<p><strong>例子：</strong></p>
<p>我们用包子举例，等待与唤醒机制也被称作<strong>线程之间的通信</strong>。<strong>重点：有效的利用资源（生产包子，吃一个包子，在生产包子，吃一个包子。。。）</strong>这里的<strong>资源</strong>呢，指的就是包子（生产一个吃一个），</p>
<p><strong>重点解释：</strong></p>
<p>通信：对包子的状态进行判断（判断是否有包子，如果没有，吃包子线程则唤醒生产包子线程，吃包子线程等待，生产包子线程制作包子，做好包子之后修改包子状态，改为有包子；</p>
<p>有存在包子，生产包子线程则唤醒吃包子线程，生产包子线程等待，吃包子线程吃包子，吃完包子修改包子状态为没有）</p>
<p>他们可以反复执行，这也就叫做线程之间的通信，也被称之为等待和唤醒。</p>
<p>重点的是我们合理运用这个包子来判断到底是哪条线程在执行。</p>
<p>那等待与唤醒就要用到我们着几个方法</p>
<p><strong>等待唤醒中的方法</strong></p>
<p>等待唤醒机制就是用来解决线程之间的通信问题，使用到的3个方法的含义如下：</p>
<p>1、wait：线程不在活动，不在参与调度，进入wait set中，因此不会浪费<strong>CPU</strong>资源，也不会去竞争锁了，这个时候的线程即是<strong>WAITING</strong>状态，它还要等待别的线程执行一个<strong>特别的动作</strong>，也即是<strong>”通知“（ notify() ）</strong>在这个对象上等待的线程从wait set中释放出来，重新进入到调度队列中（ready quene）中。</p>
<p>2、notify：则选取所通知的对象的wait set中的一个线程释放，例如：餐厅有位置以后，等待最久的顾客优先入座。</p>
<p>3、notifyAll：则释放所通知对象的wait set上的全部线程</p>
<p><font color="red">注意：哪怕只通知了一个等待的线程，被通知的线程也不能立即恢复执行，因为它当初中断的地方是在同步块中，而此刻它已经不在持有锁，所以这个时候它需要再次尝试去获取锁，（很可能面临其他线程的竞争)成功以后才能调用wait方法之后的地方恢复执行。</font></p>
<p><strong>调用wait和notify所需要注意的细节</strong></p>
<p>1、wait和notify方法必须要由<strong>同一个锁对象</strong>调用，因为对应的锁对象可以通过notify唤醒<strong>使用同一个锁对象</strong>调用的wait方法后的线程</p>
<p>2、wait方法和notify方法都是属于Object类的方法，因为锁对象可以是任意对象，而任意对象的所属类都是继承了Object类</p>
<p>3、<strong>wait方法和notify方法必须使用在同步代码块或者是同步函数中使用</strong>，因为必须要通过锁对象才能调用者两个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分析：需要哪些类</span></span><br><span class="line"><span class="comment"> * 		1、资源类：包子</span></span><br><span class="line"><span class="comment"> * 			设置包子的属性 ：皮   馅料  状态：1、有包子true 2、没包子false</span></span><br><span class="line"><span class="comment"> * 		2、生产者（包子铺)： 线程类可以继承Thread </span></span><br><span class="line"><span class="comment"> * 			设置线程任务（run)，重写run方法 -- 生产包子(对包子状态进行判断true或者false)</span></span><br><span class="line"><span class="comment"> * 			true:有包子，包子铺调用wait方法进入等待状态</span></span><br><span class="line"><span class="comment"> * 			false:没有包子，包子铺生产包子（可以增加趣味性，生产两种包子）</span></span><br><span class="line"><span class="comment"> * 			即有两种状态，(i%2==0)这样是不是就有两个状态了</span></span><br><span class="line"><span class="comment"> * 			包子铺生产好了包子修改状态为true</span></span><br><span class="line"><span class="comment"> * 			唤醒吃货线程，让吃货线程吃包子</span></span><br><span class="line"><span class="comment"> * 		   消费者（吃货）类：是一个线程类，可以继承Thread</span></span><br><span class="line"><span class="comment"> * 			设置线程任务（run），重写run方法 -- 吃包子(对包子的状态进行判断true或者false)</span></span><br><span class="line"><span class="comment"> *			false:没有包子，吃货线程调用wait方法，进入等待状态</span></span><br><span class="line"><span class="comment"> *			true:有包子，吃货吃包子，吃货吃完包子，修改包子的状态为false</span></span><br><span class="line"><span class="comment"> *			吃货唤醒包子线程，生产包子</span></span><br><span class="line"><span class="comment"> *		3、测试类：</span></span><br><span class="line"><span class="comment"> *			包含main方法的类，是程序执行的入口，启动程序</span></span><br><span class="line"><span class="comment"> *			创建包子对象，创建包子铺线程，开启</span></span><br><span class="line"><span class="comment"> *			创建吃货线程，开启</span></span><br><span class="line"><span class="comment"> */</span>	</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-5、生产者与消费者"><a href="#9-5、生产者与消费者" class="headerlink" title="9.5、生产者与消费者"></a>9.5、生产者与消费者</h2><p><strong>等待与唤醒机制，其实就是经典的生产者与消费者的问题</strong></p>
<p>就拿生产包子和消费包子来说等待唤醒机制如何有效的利用资源</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">包子铺生产包子，吃货线程消费包子当。</span><br><span class="line">包子没有时（包子状态为false），吃货线程等待，包子铺线程生产包子（即包子状态为true），</span><br><span class="line">并通知吃货线程（解除吃货线程的等待状态），因为此时已经有包子了，那么包子铺线程进入等待状态。</span><br><span class="line">接下来，吃货线程能否进一步执行，取决于锁的获取情况，如果吃货获取到锁，那么就执行吃包子动作，</span><br><span class="line">包子吃完（包子状态为false），并通知包子铺线程（解除包子铺的等待状态），吃货线程进入等待，</span><br><span class="line">包子铺线程是否能够进一步执行，则取决于锁的获取情况</span><br></pre></td></tr></table></figure>

<p><strong>代码演示：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="comment">//皮</span></span><br><span class="line">	String pi;（wrapper）</span><br><span class="line">	<span class="comment">//馅</span></span><br><span class="line">	String xian;（stuffing）</span><br><span class="line">	<span class="comment">//包子的状态为true或者false。设置初始值为false</span></span><br><span class="line">	<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	生产者（包子铺)： 线程类可以继承Thread </span></span><br><span class="line"><span class="comment"> 		设置线程任务（run)，重写run方法 -- 生产包子(对包子状态进行判断true或者false)</span></span><br><span class="line"><span class="comment"> 		true:有包子，包子铺调用wait方法进入等待状态</span></span><br><span class="line"><span class="comment"> 		false:没有包子，包子铺生产包子（可以增加趣味性，生产两种包子）</span></span><br><span class="line"><span class="comment"> 		即有两种状态，(i%2==0)这样是不是就有两个状态了</span></span><br><span class="line"><span class="comment"> 		包子铺生产好了包子修改状态为true</span></span><br><span class="line"><span class="comment"> 		唤醒吃货线程，让吃货线程吃包子</span></span><br><span class="line"><span class="comment"> 	注意：</span></span><br><span class="line"><span class="comment"> 		包子铺线程和包子线程关系 - 通信关系（互斥关系）</span></span><br><span class="line"><span class="comment"> 		必须同时同步技术保证两个线程只能有一个在执行</span></span><br><span class="line"><span class="comment"> 	锁对象必须保证唯一，可以使用包子对象作为锁对象。</span></span><br><span class="line"><span class="comment"> 	包子铺类和吃货类需要吧包子对象作为参数传递进来</span></span><br><span class="line"><span class="comment"> 		1、需要在成员位子创建一个包子变量</span></span><br><span class="line"><span class="comment"> 		2、使用带参数构造方法，为这个包子变量赋值</span></span><br><span class="line"><span class="comment"> 		</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//包子铺类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 1、需要定义在成员位置创建一个变量</span></span><br><span class="line">	<span class="keyword">private</span> Demo01 bz;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2、使用带参数构造方法，为这个包子变量赋值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Demo02</span><span class="params">(Demo01 bz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.bz = bz;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置线程任务（run) 生产包子</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 定义一个变量</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">				<span class="comment">// 对包子状态进行判断</span></span><br><span class="line">				<span class="keyword">if</span> (bz.flag == <span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="comment">// 包子铺调用wait方法进入等待状态</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						bz.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 被唤醒之后执行，包子铺生产包子</span></span><br><span class="line">				<span class="comment">// 增加一些趣味性，交替产生两种包子</span></span><br><span class="line">				<span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// 生产薄片包子</span></span><br><span class="line">					bz.pi = <span class="string">&quot;薄片&quot;</span>;</span><br><span class="line">					bz.xian = <span class="string">&quot;三鲜&quot;</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">// 生产厚皮，牛肉馅</span></span><br><span class="line">					bz.pi = <span class="string">&quot;厚皮&quot;</span>;</span><br><span class="line">					bz.xian = <span class="string">&quot;牛肉&quot;</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				count++;</span><br><span class="line">				System.out.println(<span class="string">&quot;包子铺正在生产&quot;</span> + bz.pi + bz.xian + <span class="string">&quot;包子&quot;</span>);</span><br><span class="line">				<span class="comment">// 生产包子需要3秒</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 此时包子铺生产好了包子</span></span><br><span class="line">				<span class="comment">// 修改包子的状态为true</span></span><br><span class="line">				bz.flag = <span class="keyword">true</span>;</span><br><span class="line">				<span class="comment">// 唤醒吃货线程，让吃货线程吃包子</span></span><br><span class="line">				bz.notify();</span><br><span class="line">				System.out.println(<span class="string">&quot;包子铺已经生产好了：&quot;</span> + bz.pi + bz.xian + <span class="string">&quot;包子，吃货们可以开始吃了&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  消费者（吃货）类：是一个线程类，可以继承Thread</span></span><br><span class="line"><span class="comment">  		设置线程任务（run），重写run方法 -- 吃包子(对包子的状态进行判断true或者false)</span></span><br><span class="line"><span class="comment"> 		false:没有包子，吃货线程调用wait方法，进入等待状态</span></span><br><span class="line"><span class="comment"> 		true:有包子，吃货吃包子，吃货吃完包子，修改包子的状态为false</span></span><br><span class="line"><span class="comment"> 		吃货唤醒包子线程，生产包子</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">	<span class="comment">//1、需要在成员位置创建一个包子变量</span></span><br><span class="line">	<span class="keyword">private</span> Demo01 bz;</span><br><span class="line">	<span class="comment">//2、使用带参数的构造方法，为这个包子变量赋值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Demo03</span><span class="params">(Demo01 bz)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.bz = bz;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//设置线程任务（run)  吃包子</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">//使用死循环，让吃货一直吃包子</span></span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//必须同时同步技术保证两个线程只能有一个在执行</span></span><br><span class="line">			<span class="keyword">synchronized</span> (bz) &#123;</span><br><span class="line">				<span class="comment">//对包子状态进行判断</span></span><br><span class="line">				<span class="keyword">if</span>(bz.flag == <span class="keyword">false</span>)&#123;</span><br><span class="line">					<span class="comment">//调用吃货的wait方法进入等待状态</span></span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						bz.wait();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//被唤醒之后执行的代码，吃包子</span></span><br><span class="line">				System.out.println(<span class="string">&quot;吃货正在吃：&quot;</span> + bz.pi</span><br><span class="line">						+bz.xian +<span class="string">&quot;的包子&quot;</span>);</span><br><span class="line">				<span class="comment">//修改包子的状态为false </span></span><br><span class="line">				bz.flag = <span class="keyword">false</span>;</span><br><span class="line">				<span class="comment">//唤醒包子铺线程</span></span><br><span class="line">				bz.notify();</span><br><span class="line">				System.out.println(<span class="string">&quot;吃货已经把&quot;</span> +bz.pi + bz.xian</span><br><span class="line">					+<span class="string">&quot;的包子吃完了，包子铺开始生产包子&quot;</span>);</span><br><span class="line">				System.out.println(<span class="string">&quot;-----------------------&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**		</span></span><br><span class="line"><span class="comment"> * 3、测试类：</span></span><br><span class="line"><span class="comment"> *		包含main方法的类，是程序执行的入口，启动程序</span></span><br><span class="line"><span class="comment"> *		创建包子对象，创建包子铺线程，开启</span></span><br><span class="line"><span class="comment"> *		创建吃货线程，开启</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo04</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//创建包子对象：</span></span><br><span class="line">		Demo01 bz = <span class="keyword">new</span> Demo01();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建包子铺线程，开启，生产包子</span></span><br><span class="line">		Demo02 baozipu = <span class="keyword">new</span> Demo02(bz);</span><br><span class="line">		baozipu.start();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//创建吃货线程，开启，吃包子</span></span><br><span class="line">		Demo03 chibaozi = <span class="keyword">new</span> Demo03(bz);</span><br><span class="line">		chibaozi.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第十章、线程池"><a href="#第十章、线程池" class="headerlink" title="第十章、线程池"></a>第十章、线程池</h1><h2 id="10-1、线程池思想概念"><a href="#10-1、线程池思想概念" class="headerlink" title="10.1、线程池思想概念"></a>10.1、线程池思想概念</h2><p>我们使用线程的时候就去创建一个线程，这样实现起来非常简单，但是就会有这样的一个问题：</p>
<p>如果兵法的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁的创建线程就会大大降低系统的效率，因为频繁创建线程和销毁线程需要时间。</p>
<p>那么有没有一种办法可以使线程可以复用，就是执行完一个任务，并不被销毁，而是可以继续执行其他的任务？</p>
<p>在Java中可以通过线程池来达到这样的效果，今天我们就来详细讲解一下Java线程池</p>
<h2 id="10-2、线程池概念"><a href="#10-2、线程池概念" class="headerlink" title="10.2、线程池概念"></a>10.2、线程池概念</h2><ul>
<li>线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</li>
</ul>
<p>由于线程池中有很多操作都是与优化资源相关的，我们在这里就不多叙述，我们通过一张图来了解线程的工作原理</p>
<p>线程池可以理解成一个容器，容器我们可以理解成什么？是不是可以理解成一个集合(ArrayList，HashSet，LinkedList，HashMap)这里我们可以用什么呢？是不是可以用一个LinkedList也可以用ArrayList集合这些集合的泛型就放什么呢，就放我们的线程。所以这个线程池实际上就是我们的集合就是我们的容器。</p>
<p>我们来画个图，来理解一下线程池的概念。在这里面创建一下线程到我们的集合中来</p>
<p>使用add方法添加线程</p>
<ol>
<li><p>当程序第一次启动的时候，我们可以创建多个线程，保存到一个集合中</p>
</li>
<li><p>当我们想要使用线程的时候，就可以从集合中取出线程来使用</p>
</li>
<li><p>Thread th1 = list.remove(0) :返还的是被移除的元素（线程只能被 一个任务使用）</p>
</li>
<li><p>如果使用Thread th2 =  LinkedList.removeFirest()</p>
</li>
<li><p>当使用线程需要把线程归还给线程池</p>
</li>
<li><p>list.add(th1);</p>
</li>
<li><p>Linked.addLast(th2); </p>
</li>
<li><p>所以线程里面有一个叫做队列的东西。依次拿出线程使用</p>
</li>
</ol>
<p>在JDK1.5以后，JDK内置了线程池，我们可以直接使用。</p>
<p>这就是线程池的原理</p>
<p>合理利用线程池能够带来三个好处：</p>
<ol>
<li><p>降低资源消耗，减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</p>
</li>
<li><p>提高相应速度，当任务到达时，任务可以不需要的等到线程创建就可以立即执行</p>
</li>
<li><p>提高线程的可管理性，可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而把服务器累趴下（每个线程需要大约1MB，线程开的越多，消耗的内存也就越大，最后死机）</p>
</li>
</ol>
<h2 id="10-3、线程池的使用"><a href="#10-3、线程池的使用" class="headerlink" title="10.3、线程池的使用"></a>10.3、线程池的使用</h2><p>Java里面线程池的顶级接口是java.util.concurrent,Executor,但是严格意义上来说Executor并不是一个线程池，而是一个执行线程的工具。真正的线程池接口是java.util.concurrent.ExecutorService。要配置一个线程池是比较复杂的，尤其是对于线程池的原理并不是很清楚的情况下，很有可能配置的线程池不是比较优的。因此在java.util.concurrent.Executors线程工程类里面提供了一些镜头工厂，生成一些常用的线程池，官方建议使用Executors工程类来创建线程池对象</p>
<p>Executors类中有个创建线程池的方法如下：</p>
<ul>
<li>public static ExecutorService newFixedThreadPool(int nThreads):返回线程池对象（创建的是有界线的线程池，也就是线程池中的线程个数可以指定最大数量）</li>
</ul>
<p>获取到一个线程池ExecutorService，那怎么使用呢，在这里定义了一个使用线程池对象的方法如下：</p>
<ul>
<li>public Future&lt;?&gt; submit(Runnable task)：获取线程池的某一个对象并执行</li>
<li>Future接口：用来记录线程任务执行完毕后产生的结果，线程池创建与使用。</li>
</ul>
<p>使用线程池中线程对象的步骤：</p>
<ol>
<li><p>创建线程池对象</p>
</li>
<li><p>创建Runnable接口子类对象（task）</p>
</li>
<li><p>提交Runnable接口子类对象。（task task）</p>
</li>
<li><p>关闭线程池（一般不做）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 	线程池：JDK1.5以后提供的</span></span><br><span class="line"><span class="comment"> 	在java.util.concurrent.Executors</span></span><br><span class="line"><span class="comment"> 	线程池工厂类，用来生产线程池</span></span><br><span class="line"><span class="comment"> 	Executors有个静态方法 -- 生产线程池的方法</span></span><br><span class="line"><span class="comment"> 	static ExecutorService newFicedThreadPool(int nThreads)</span></span><br><span class="line"><span class="comment"> 	创建一个可重用固定线程数的线程池</span></span><br><span class="line"><span class="comment"> 	参数：</span></span><br><span class="line"><span class="comment"> 		int nThreads:创建线程池中包含的线程数量</span></span><br><span class="line"><span class="comment"> 	返回值:</span></span><br><span class="line"><span class="comment"> 		ExecutorService接口，返回的是ExecutorService</span></span><br><span class="line"><span class="comment"> 		接口的实现类对象，我们可以使用ExecutorService接口接收（面向接口编程)</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment"> 	java.util.concurrent.ExectorService:线程池接口</span></span><br><span class="line"><span class="comment"> 		用来从线程池中获取线程，调用start方法，执行线程任务</span></span><br><span class="line"><span class="comment"> 			submit（Runnable task) 提交一个Runnable任务用于执行</span></span><br><span class="line"><span class="comment"> 			</span></span><br><span class="line"><span class="comment"> 		关闭/消耗线程池的方法</span></span><br><span class="line"><span class="comment"> 			shutdown()</span></span><br><span class="line"><span class="comment"> 			</span></span><br><span class="line"><span class="comment"> 		线程池的使用步骤：</span></span><br><span class="line"><span class="comment"> 		1、使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool</span></span><br><span class="line"><span class="comment"> 		生产一个执行线程数量的线程池</span></span><br><span class="line"><span class="comment"> 		2、创建一个类，实现Runnable接口，重写run方法，设置线程任务</span></span><br><span class="line"><span class="comment"> 		3、调用ExectorService中的方法submit，传递线程任务(实现类），开启线程，执行run方法</span></span><br><span class="line"><span class="comment"> 		4、调用ExectorService中的方法shutdown销毁线程池（不建议使用）</span></span><br><span class="line"><span class="comment"> 		注意：我们使用线程池的目的是为了反复使用，销毁了就没了对吧。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//1、使用线程池的工厂类Executors里面提供的静态方法newFixedThreadPool</span></span><br><span class="line"><span class="comment">// 		生产一个执行线程数量的线程池</span></span><br><span class="line">		ExecutorService es = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		3、调用ExectorService中的方法submit，传递线程任务(实现类），开启线程，执行run方法</span></span><br><span class="line">		es.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line"><span class="comment">//		线程池会一直开启，使用完了线程，会自动把线程归还给线程池，线程池可以继续使用</span></span><br><span class="line">		es.submit(<span class="keyword">new</span> RunnableImpl());<span class="comment">//pool-1-thread-1创建了一个新的线程</span></span><br><span class="line">		es.submit(<span class="keyword">new</span> RunnableImpl());<span class="comment">//pool-1-thread-2创建了一个新的线程</span></span><br><span class="line"><span class="comment">//		4、调用ExectorService中的方法shutdown销毁线程池（不建议使用）</span></span><br><span class="line">		es.shutdown();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//线程池被销毁了，便不能在执行了。会抛出异常</span></span><br><span class="line">    <span class="comment">//不能在获取线程</span></span><br><span class="line">		es.submit(<span class="keyword">new</span> RunnableImpl());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableImpl</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName()+<span class="string">&quot;:&quot;</span>+i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Egret</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://jegret.cn/2021/05/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/">https://jegret.cn/2021/05/16/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://jegret.cn" target="_blank">Egret's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/08/16/MfkZmv3NWYtocyF.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://i.loli.net/2021/08/15/kr47K5WcQu3Moqh.png" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/08/15/kr47K5WcQu3Moqh.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://i.loli.net/2021/08/15/17OFMeYbTIhkrxp.png" target="_blank"><img class="post-qr-code-img" src="https://i.loli.net/2021/08/15/17OFMeYbTIhkrxp.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/07/16/MySQL%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://i.loli.net/2021/08/16/1uP9UXdCTAgJezy.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/16/JavaIO%E6%B5%81%E5%B8%B8%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src="https://i.loli.net/2021/08/16/BHmsfL4htRF8GqE.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JavaIO流常用对象与方法详解</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/./img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Egret</div><div class="author-info__description">石入谷，鱼入海</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">24</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">13</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/j-egret"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/J-egrets" target="_blank" title="Github"><i class="iconfont icon-github"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/J-egrets/egretBaby/img/QQ二维码202201272135218.jpg" target="_blank" title="QQ"><i class="iconfont icon-qq"></i></a><a class="social-icon" href="https://cdn.jsdelivr.net/gh/J-egrets/egretBaby/img/微信二维码202201272135011.jpg" target="_blank" title="微信"><i class="iconfont icon-weixin"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">欢迎来到Egret的博客! <img src="https://butterfly.lete114.top/img/my_bg.gif" width="280em"></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">第一章、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-text">1.1 并发与并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-text">1.2 线程与进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%B1%BB"><span class="toc-text">1.3 创建线程类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%8E%9F%E7%90%86"><span class="toc-text">第二章、多线程执行原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8E%9F%E7%90%86"><span class="toc-text">2.1、多线程原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-text">2.2、多线程的好处</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%E3%80%81Thread%E7%B1%BB"><span class="toc-text">第三章、Thread类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E3%80%81thread%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text">3.1、thread类的常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1%E3%80%81%E8%8E%B7%E5%8F%96%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0"><span class="toc-text">3.1.1、获取线程名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2%E3%80%81%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0"><span class="toc-text">3.1.2、设置线程名称</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3%E3%80%81%E8%AE%BE%E7%BD%AE%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text">3.1.3、设置守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9D%A1%E7%9C%A0"><span class="toc-text">3.1.4、线程睡眠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5%E3%80%81%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">3.1.5、设置线程优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-6%E3%80%81%E7%BA%BF%E7%A8%8B%E8%AE%A9%E6%AD%A5"><span class="toc-text">3.1.6、线程让步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-7%E3%80%81%E7%BA%BF%E7%A8%8B%E6%8F%92%E9%98%9F"><span class="toc-text">3.1.7、线程插队</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%E3%80%81%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AC%AC%E4%BA%8C%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-text">第四章、实现多线程的第二种方法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1%E3%80%81%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-text">4.1、实现Runnable接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%E3%80%81Thread%E5%92%8CRunnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">第五章、Thread和Runnable接口的区别</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%E3%80%81%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">第六章、匿名内部类的方式实现多线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E3%80%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-text">第七章、线程安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">7.1  线程同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-text">7.2、同步代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E3%80%81%E5%90%8C%E6%AD%A5%E5%9F%BA%E6%95%B0%E5%8E%9F%E7%90%86"><span class="toc-text">7.3、同步基数原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4%E3%80%81%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-text">7.4、同步方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5%E3%80%81%E9%9D%99%E6%80%81%E9%94%81"><span class="toc-text">7.5、静态锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6%E3%80%81%E7%BA%BF%E7%A8%8B%E8%84%8F%E8%AF%BB%E9%97%AE%E9%A2%98"><span class="toc-text">7.6、线程脏读问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-7%E3%80%81%E5%86%85%E5%AD%98%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98-%E5%92%8C-volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">7.7、内存的可见性问题 和 volatile关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-8%E3%80%81synchronized%E9%94%81%E7%9A%84%E9%87%8D%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">7.8、synchronized锁的重入机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-9%E3%80%81%E6%AD%BB%E9%94%81"><span class="toc-text">7.9、死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-10%E3%80%81Lock%E9%94%81"><span class="toc-text">7.10、Lock锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">第八章、线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1%E3%80%81%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E6%A6%82%E8%BF%B0"><span class="toc-text">8.1、线程状态概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-Timed-Waiting%EF%BC%88%E8%AE%A1%E6%97%B6%E7%AD%89%E5%BE%85%EF%BC%89"><span class="toc-text">8.2 Timed Waiting（计时等待）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-BLOCKED%EF%BC%88%E9%94%81%E9%98%BB%E5%A1%9E%EF%BC%89"><span class="toc-text">8.3 BLOCKED（锁阻塞）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-4-Waiting%EF%BC%88%E6%97%A0%E9%99%90%E7%AD%89%E5%BE%85%EF%BC%89"><span class="toc-text">8.4 Waiting（无限等待）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-5%E3%80%81wait%E5%92%8Cnotify"><span class="toc-text">8.5、wait和notify</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0%E3%80%81%E7%AD%89%E5%BE%85%E4%B8%8E%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="toc-text">第九章、等待与唤醒机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1%E3%80%81%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">9.1、线程之间的通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A4%84%E7%90%86%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-text">9.2、为什么要处理线程通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3%E3%80%81%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%9C%89%E6%95%88%E5%88%A9%E7%94%A8%E8%B5%84%E6%BA%90"><span class="toc-text">9.3、如何保证线程间通信有效利用资源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4%E3%80%81%E7%AD%89%E5%BE%85%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="toc-text">9.4、等待唤醒机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E4%B8%8E%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text">9.5、生产者与消费者</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">第十章、线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%9D%E6%83%B3%E6%A6%82%E5%BF%B5"><span class="toc-text">10.1、线程池思想概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A6%82%E5%BF%B5"><span class="toc-text">10.2、线程池概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">10.3、线程池的使用</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/20/JavaWeb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" title="JavaWeb基础知识总结"><img src="https://i.loli.net/2021/08/15/gNcT3SztMsAEveX.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb基础知识总结"/></a><div class="content"><a class="title" href="/2022/01/20/JavaWeb%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" title="JavaWeb基础知识总结">JavaWeb基础知识总结</a><time datetime="2022-01-20T09:07:08.000Z" title="发表于 2022-01-20 17:07:08">2022-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/19/%E5%9B%BE%E5%BA%8A/" title="Github免费图床搭建"><img src="https://i.loli.net/2021/08/15/3rjcmPV7nZU6l1s.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Github免费图床搭建"/></a><div class="content"><a class="title" href="/2022/01/19/%E5%9B%BE%E5%BA%8A/" title="Github免费图床搭建">Github免费图床搭建</a><time datetime="2022-01-19T09:07:08.000Z" title="发表于 2022-01-19 17:07:08">2022-01-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/18/IDEA2021.1.2%E5%88%9B%E5%BB%BAJavaWeb%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/" title="IDEA2021.1.2创建JavaWeb项目步骤"><img src="https://i.loli.net/2021/08/16/vxTrJ2UCtw8zipb.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IDEA2021.1.2创建JavaWeb项目步骤"/></a><div class="content"><a class="title" href="/2022/01/18/IDEA2021.1.2%E5%88%9B%E5%BB%BAJavaWeb%E9%A1%B9%E7%9B%AE%E6%AD%A5%E9%AA%A4/" title="IDEA2021.1.2创建JavaWeb项目步骤">IDEA2021.1.2创建JavaWeb项目步骤</a><time datetime="2022-01-18T09:07:08.000Z" title="发表于 2022-01-18 17:07:08">2022-01-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/21/JavaWeb%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E7%82%B9%E5%90%8D%E7%B3%BB%E7%BB%9F/" title="JavaWeb项目——学生点名系统"><img src="https://i.loli.net/2021/08/16/DdCBglSozKR5iqk.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaWeb项目——学生点名系统"/></a><div class="content"><a class="title" href="/2021/08/21/JavaWeb%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%AD%A6%E7%94%9F%E7%82%B9%E5%90%8D%E7%B3%BB%E7%BB%9F/" title="JavaWeb项目——学生点名系统">JavaWeb项目——学生点名系统</a><time datetime="2021-08-21T14:19:19.000Z" title="发表于 2021-08-21 22:19:19">2021-08-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/08/20/JavaSe%E8%BF%9B%E9%98%B6%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" title="JavaSe进阶项目——图书管理系统"><img src="https://i.loli.net/2021/08/15/a37dwZDX2GPzToE.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JavaSe进阶项目——图书管理系统"/></a><div class="content"><a class="title" href="/2021/08/20/JavaSe%E8%BF%9B%E9%98%B6%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/" title="JavaSe进阶项目——图书管理系统">JavaSe进阶项目——图书管理系统</a><time datetime="2021-08-20T10:56:22.000Z" title="发表于 2021-08-20 18:56:22">2021-08-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div class="copyright"><span style="color:gray"> &copy;2020 - 2022 </span> <i id="heartbeat" class="fa fas fa-heartbeat"></i> <span style="color:gray">Egret</span></div><div class="footer_custom_text"><p style="color:gray">很高兴认识你</p></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="783093086" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-preload="none" data-autoplay="true" muted></div><script src="js\cursor.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="true"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/haruto.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>